	<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
	<html>
	<head>
	<style media="screen" type="text/css">
	body {
		color: #000000 ;
		background-color: #FFFFFF ;
		font-family: sans-serif ;
		text-align: justify ;
		margin-right: 20px ;
		margin-left: 20px ;
	}

	h1, h2, h3, h4 {
		font-weight: normal ;
		font-style: italic ;
	}

	h1 {
		padding-top: 0.4em ;
		padding-bottom: 0.4em ;
		padding-left: 20px ;
		margin-left: -20px ;
		background-color: #AAAAAA;
	}
	
	h2 {
		padding-top: 0.1em ;
		padding-bottom: 0.1em ;
		padding-left: 20px ;
		margin-left: -20px ;
		background-color: #AAAAAA;
	}

	h3 {
		padding-left: 8px ;
		border-left: solid #AAAAAA 1em ;
	}

	table h3 {
		padding-left: 0px ;
		border-left: none ; 
	}

	a:link {
		color: #000080 ;
		background-color: inherit ;
		text-decoration: none ;
	}

	a:visited {
		background-color: inherit ;
		text-decoration: none ;
	}

	a:link:hover, a:visited:hover {
		color: #000080 ;
		background-color: #E0E0FF ;
	}

	a:link:active, a:visited:active {
		color: #FF0000 ;
	}

	hr {
		border: 0 ;
		height: 1px ;
		color: #a0a0a0 ;
		background-color: #a0a0a0 ;
	}

	:target {
		background-color: #AAAAAA ;
		border: solid #a0a0a0 2px ;
	}
	</style>

	<title>MagLua Reference Manual</title>
	<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
	</head>
	<body>
	&nbsp;&nbsp;&nbsp;&nbsp;<H1>MagLua</H1><br>&nbsp;&nbsp;&nbsp;&nbsp;<p>MagLua is an extension to the base Lua language that allows a user to build micromagnetic simulations with the Lua scripting language.&nbsp;&nbsp;&nbsp;&nbsp;<p>MagLua is composed of 2 conceptual parts following the Data Oriented Design paradigm<br>&nbsp;&nbsp;&nbsp;&nbsp;<ul><li>Data - Spin vectors and fields, these are held in a <a href="#SpinSystem">SpinSystem</a>.<li>Transformations - Objects which modify data. Some calculate fields based on spins or external influences such as <a href="#Anisotropy">Anisotropy</a>, <a href="#Dipole">Dipole</a> and <a href="#Thermal">Thermal</a>, others update the spin vectors such as <a href="#LLG.Cartesian">LLG.Cartesian</a>.&nbsp;&nbsp;&nbsp;&nbsp;</ul>&nbsp;&nbsp;&nbsp;&nbsp;<p>The <a href="#Index">Index</a> has links to all objects, methods and functions provided by MagLua.</p><p>The following is a list of the objects and functions which may be combined to create a simulation.<p>
<h2><a name="Anisotropy">Anisotropy</a></h2>
<p>
Computes the single ion anisotropy fields for a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>Anisotropy.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Anisotropy:add"><code>Anisotropy:add</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a lattice site to the anisotropy calculation</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s, 1 number: The first <a href="#3Vector">3Vector</a> defines a lattice site, the second defines an easy axis and is normalized. The number defines the strength of the Anisotropy.</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:apply"><code>Anisotropy:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:axis"><code>Anisotropy:axis</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the site, easy axis and strength at the given index.</dd>
<dt>Input</dt><dd>1 Integer: Index of the axis.</dd>
<dt>Output</dt><dd>1 Table of 3 Integers, 1 Table of 3 Numbers, 1 Number: Coordinates of the site, direction of the easy axis and strength of the easy axis.</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:get"><code>Anisotropy:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Fetch the anisotropy direction and magnitude at a given site.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The <a href="#3Vector">3Vector</a> defines a lattice site.</dd>
<dt>Output</dt><dd>4 Numbers: The first 3 numbers define the normal axis, the 4th number is the magnitude.</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:member"><code>Anisotropy:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:mergeAxes"><code>Anisotropy:mergeAxes</code></a></h3>
<dl>
<dt>Description</dt><dd>Combine common site-axes into a single axis with a combined strength</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:numberOfAxes"><code>Anisotropy:numberOfAxes</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the number of easy axes in the operator</dd>
<dt>Output</dt><dd>1 Integer: Number of easy axes.</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:nx"><code>Anisotropy:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:ny"><code>Anisotropy:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:nz"><code>Anisotropy:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:scale"><code>Anisotropy:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Anisotropy:setScale"><code>Anisotropy:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h2><a name="AppliedField">AppliedField</a></h2>
<p>
Applies an external, global field to a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>AppliedField.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="AppliedField:add"><code>AppliedField:add</code></a></h3>
<dl>
<dt>Description</dt><dd>Add the direction and strength of the Applied Field</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The <a href="#3Vector">3Vector</a> defines the strength and direction of the applied field addition</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:get"><code>AppliedField:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the direction and strength of the Applied Field</dd>
<dt>Output</dt><dd>3 numbers: The x, y and z components of the field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:member"><code>AppliedField:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:nx"><code>AppliedField:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:ny"><code>AppliedField:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:nz"><code>AppliedField:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:scale"><code>AppliedField:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:set"><code>AppliedField:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the direction and strength of the Applied Field</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The <a href="#3Vector">3Vector</a> defines the strength and direction of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:setScale"><code>AppliedField:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:setX"><code>AppliedField:setX</code></a></h3>
<dl>
<dt>Description</dt><dd>set the X component of the applied field.</dd>
<dt>Input</dt><dd>1 Number: X component of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:setY"><code>AppliedField:setY</code></a></h3>
<dl>
<dt>Description</dt><dd>set the Y component of the applied field.</dd>
<dt>Input</dt><dd>1 Number: Y component of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:setZ"><code>AppliedField:setZ</code></a></h3>
<dl>
<dt>Description</dt><dd>set the Z component of the applied field.</dd>
<dt>Input</dt><dd>1 Number: Z component of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:x"><code>AppliedField:x</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the X component of the applied field.</dd>
<dt>Output</dt><dd>1 Number: X component of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:y"><code>AppliedField:y</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the Y component of the applied field.</dd>
<dt>Output</dt><dd>1 Number: Y component of the applied field</dd>
</dl><hr>
<p>
<h3><a name="AppliedField:z"><code>AppliedField:z</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the Z component of the applied field.</dd>
<dt>Output</dt><dd>1 Number: Z component of the applied field</dd>
</dl><hr>
<p>
<h2><a name="Array.Double">Array.Double</a></h2>
<p>
Class for 3D Data Arrays
<p><dl><dt>Array.Double.new() takes the following arguments</dt><dd>0 to 3 Integers: Length of each dimension X, Y and Z. Default values are 1.</dd></dl>
<hr>
<p>
<h3><a name="Array.Double:addAt"><code>Array.Double:addAt</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a value to an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value: indices(XYZ) of the element to modify, default values are 1. Last argument is the value to add</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:dot"><code>Array.Double:dot</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product of the current array and another of equal size and type</dd>
<dt>Input</dt><dd>1 Arrays: other array</dd>
<dt>Output</dt><dd>1 Value: result of dot product</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:get"><code>Array.Double:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element from the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table): indices(XYZ) of the element to fetch default values are 1</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:max"><code>Array.Double:max</code></a></h3>
<dl>
<dt>Description</dt><dd>Find maximum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:mean"><code>Array.Double:mean</code></a></h3>
<dl>
<dt>Description</dt><dd>Find mean of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:min"><code>Array.Double:min</code></a></h3>
<dl>
<dt>Description</dt><dd>Find minimum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:nx"><code>Array.Double:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the X dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the X dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:ny"><code>Array.Double:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Y dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Y dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:nz"><code>Array.Double:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Z dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Z dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:pairwiseMultiply"><code>Array.Double:pairwiseMultiply</code></a></h3>
<dl>
<dt>Description</dt><dd>Multiply each data in this array with the data in another storing in a destination array</dd>
<dt>Input</dt><dd>2 Arrays: The pairwise scaling array and the destination array</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:sameSize"><code>Array.Double:sameSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if a given array has the same dimensions</dd>
<dt>Input</dt><dd>1 Array</dd>
<dt>Output</dt><dd>1 Boolean: True if sizes match</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:scale"><code>Array.Double:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale all values in the array by the given value</dd>
<dt>Input</dt><dd>1 Value: The scaling factor</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:set"><code>Array.Double:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value or 1 Array: indices(XYZ) of the element to set, default values are 1. Last argument is the new value. If the last argument is an array then all elements in the array are copied to the calling object.</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:setAll"><code>Array.Double:setAll</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array to the given value</dd>
<dt>Input</dt><dd>1 Value: The new value for all element entries</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:sum"><code>Array.Double:sum</code></a></h3>
<dl>
<dt>Description</dt><dd>Find sum of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Double:zero"><code>Array.Double:zero</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array 0</dd>
</dl><hr>
<p>
<h2><a name="Array.DoubleComplex">Array.DoubleComplex</a></h2>
<p>
Class for 3D Data Arrays
<p><dl><dt>Array.DoubleComplex.new() takes the following arguments</dt><dd>0 to 3 Integers: Length of each dimension X, Y and Z. Default values are 1.</dd></dl>
<hr>
<p>
<h3><a name="Array.DoubleComplex:addAt"><code>Array.DoubleComplex:addAt</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a value to an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value: indices(XYZ) of the element to modify, default values are 1. Last argument is the value to add</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:dot"><code>Array.DoubleComplex:dot</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product of the current array and another of equal size and type</dd>
<dt>Input</dt><dd>1 Arrays: other array</dd>
<dt>Output</dt><dd>1 Value: result of dot product</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:get"><code>Array.DoubleComplex:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element from the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table): indices(XYZ) of the element to fetch default values are 1</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:max"><code>Array.DoubleComplex:max</code></a></h3>
<dl>
<dt>Description</dt><dd>Find maximum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:mean"><code>Array.DoubleComplex:mean</code></a></h3>
<dl>
<dt>Description</dt><dd>Find mean of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:min"><code>Array.DoubleComplex:min</code></a></h3>
<dl>
<dt>Description</dt><dd>Find minimum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:nx"><code>Array.DoubleComplex:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the X dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the X dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:ny"><code>Array.DoubleComplex:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Y dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Y dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:nz"><code>Array.DoubleComplex:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Z dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Z dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:pairwiseMultiply"><code>Array.DoubleComplex:pairwiseMultiply</code></a></h3>
<dl>
<dt>Description</dt><dd>Multiply each data in this array with the data in another storing in a destination array</dd>
<dt>Input</dt><dd>2 Arrays: The pairwise scaling array and the destination array</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:sameSize"><code>Array.DoubleComplex:sameSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if a given array has the same dimensions</dd>
<dt>Input</dt><dd>1 Array</dd>
<dt>Output</dt><dd>1 Boolean: True if sizes match</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:scale"><code>Array.DoubleComplex:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale all values in the array by the given value</dd>
<dt>Input</dt><dd>1 Value: The scaling factor</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:set"><code>Array.DoubleComplex:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value or 1 Array: indices(XYZ) of the element to set, default values are 1. Last argument is the new value. If the last argument is an array then all elements in the array are copied to the calling object.</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:setAll"><code>Array.DoubleComplex:setAll</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array to the given value</dd>
<dt>Input</dt><dd>1 Value: The new value for all element entries</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:sum"><code>Array.DoubleComplex:sum</code></a></h3>
<dl>
<dt>Description</dt><dd>Find sum of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.DoubleComplex:zero"><code>Array.DoubleComplex:zero</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array 0</dd>
</dl><hr>
<p>
<h2><a name="Array.Float">Array.Float</a></h2>
<p>
Class for 3D Data Arrays
<p><dl><dt>Array.Float.new() takes the following arguments</dt><dd>0 to 3 Integers: Length of each dimension X, Y and Z. Default values are 1.</dd></dl>
<hr>
<p>
<h3><a name="Array.Float:addAt"><code>Array.Float:addAt</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a value to an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value: indices(XYZ) of the element to modify, default values are 1. Last argument is the value to add</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:dot"><code>Array.Float:dot</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product of the current array and another of equal size and type</dd>
<dt>Input</dt><dd>1 Arrays: other array</dd>
<dt>Output</dt><dd>1 Value: result of dot product</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:get"><code>Array.Float:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element from the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table): indices(XYZ) of the element to fetch default values are 1</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:max"><code>Array.Float:max</code></a></h3>
<dl>
<dt>Description</dt><dd>Find maximum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:mean"><code>Array.Float:mean</code></a></h3>
<dl>
<dt>Description</dt><dd>Find mean of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:min"><code>Array.Float:min</code></a></h3>
<dl>
<dt>Description</dt><dd>Find minimum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:nx"><code>Array.Float:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the X dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the X dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:ny"><code>Array.Float:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Y dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Y dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:nz"><code>Array.Float:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Z dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Z dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:pairwiseMultiply"><code>Array.Float:pairwiseMultiply</code></a></h3>
<dl>
<dt>Description</dt><dd>Multiply each data in this array with the data in another storing in a destination array</dd>
<dt>Input</dt><dd>2 Arrays: The pairwise scaling array and the destination array</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:sameSize"><code>Array.Float:sameSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if a given array has the same dimensions</dd>
<dt>Input</dt><dd>1 Array</dd>
<dt>Output</dt><dd>1 Boolean: True if sizes match</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:scale"><code>Array.Float:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale all values in the array by the given value</dd>
<dt>Input</dt><dd>1 Value: The scaling factor</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:set"><code>Array.Float:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value or 1 Array: indices(XYZ) of the element to set, default values are 1. Last argument is the new value. If the last argument is an array then all elements in the array are copied to the calling object.</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:setAll"><code>Array.Float:setAll</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array to the given value</dd>
<dt>Input</dt><dd>1 Value: The new value for all element entries</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:sum"><code>Array.Float:sum</code></a></h3>
<dl>
<dt>Description</dt><dd>Find sum of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Float:zero"><code>Array.Float:zero</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array 0</dd>
</dl><hr>
<p>
<h2><a name="Array.FloatComplex">Array.FloatComplex</a></h2>
<p>
Class for 3D Data Arrays
<p><dl><dt>Array.FloatComplex.new() takes the following arguments</dt><dd>0 to 3 Integers: Length of each dimension X, Y and Z. Default values are 1.</dd></dl>
<hr>
<p>
<h3><a name="Array.FloatComplex:addAt"><code>Array.FloatComplex:addAt</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a value to an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value: indices(XYZ) of the element to modify, default values are 1. Last argument is the value to add</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:dot"><code>Array.FloatComplex:dot</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product of the current array and another of equal size and type</dd>
<dt>Input</dt><dd>1 Arrays: other array</dd>
<dt>Output</dt><dd>1 Value: result of dot product</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:get"><code>Array.FloatComplex:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element from the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table): indices(XYZ) of the element to fetch default values are 1</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:max"><code>Array.FloatComplex:max</code></a></h3>
<dl>
<dt>Description</dt><dd>Find maximum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:mean"><code>Array.FloatComplex:mean</code></a></h3>
<dl>
<dt>Description</dt><dd>Find mean of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:min"><code>Array.FloatComplex:min</code></a></h3>
<dl>
<dt>Description</dt><dd>Find minimum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:nx"><code>Array.FloatComplex:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the X dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the X dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:ny"><code>Array.FloatComplex:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Y dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Y dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:nz"><code>Array.FloatComplex:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Z dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Z dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:pairwiseMultiply"><code>Array.FloatComplex:pairwiseMultiply</code></a></h3>
<dl>
<dt>Description</dt><dd>Multiply each data in this array with the data in another storing in a destination array</dd>
<dt>Input</dt><dd>2 Arrays: The pairwise scaling array and the destination array</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:sameSize"><code>Array.FloatComplex:sameSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if a given array has the same dimensions</dd>
<dt>Input</dt><dd>1 Array</dd>
<dt>Output</dt><dd>1 Boolean: True if sizes match</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:scale"><code>Array.FloatComplex:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale all values in the array by the given value</dd>
<dt>Input</dt><dd>1 Value: The scaling factor</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:set"><code>Array.FloatComplex:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value or 1 Array: indices(XYZ) of the element to set, default values are 1. Last argument is the new value. If the last argument is an array then all elements in the array are copied to the calling object.</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:setAll"><code>Array.FloatComplex:setAll</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array to the given value</dd>
<dt>Input</dt><dd>1 Value: The new value for all element entries</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:sum"><code>Array.FloatComplex:sum</code></a></h3>
<dl>
<dt>Description</dt><dd>Find sum of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.FloatComplex:zero"><code>Array.FloatComplex:zero</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array 0</dd>
</dl><hr>
<p>
<h2><a name="Array.Integer">Array.Integer</a></h2>
<p>
Class for 3D Data Arrays
<p><dl><dt>Array.Integer.new() takes the following arguments</dt><dd>0 to 3 Integers: Length of each dimension X, Y and Z. Default values are 1.</dd></dl>
<hr>
<p>
<h3><a name="Array.Integer:addAt"><code>Array.Integer:addAt</code></a></h3>
<dl>
<dt>Description</dt><dd>Add a value to an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value: indices(XYZ) of the element to modify, default values are 1. Last argument is the value to add</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:dot"><code>Array.Integer:dot</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product of the current array and another of equal size and type</dd>
<dt>Input</dt><dd>1 Arrays: other array</dd>
<dt>Output</dt><dd>1 Value: result of dot product</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:get"><code>Array.Integer:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element from the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table): indices(XYZ) of the element to fetch default values are 1</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:max"><code>Array.Integer:max</code></a></h3>
<dl>
<dt>Description</dt><dd>Find maximum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:mean"><code>Array.Integer:mean</code></a></h3>
<dl>
<dt>Description</dt><dd>Find mean of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:min"><code>Array.Integer:min</code></a></h3>
<dl>
<dt>Description</dt><dd>Find minimum value and corresponding index</dd>
<dt>Output</dt><dd>1 value and 1 integer</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:nx"><code>Array.Integer:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the X dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the X dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:ny"><code>Array.Integer:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Y dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Y dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:nz"><code>Array.Integer:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the size of the Z dimension</dd>
<dt>Output</dt><dd>1 Integer: Size fo the Z dimension</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:pairwiseMultiply"><code>Array.Integer:pairwiseMultiply</code></a></h3>
<dl>
<dt>Description</dt><dd>Multiply each data in this array with the data in another storing in a destination array</dd>
<dt>Input</dt><dd>2 Arrays: The pairwise scaling array and the destination array</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:sameSize"><code>Array.Integer:sameSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if a given array has the same dimensions</dd>
<dt>Input</dt><dd>1 Array</dd>
<dt>Output</dt><dd>1 Boolean: True if sizes match</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:scale"><code>Array.Integer:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale all values in the array by the given value</dd>
<dt>Input</dt><dd>1 Value: The scaling factor</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:set"><code>Array.Integer:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of the array</dd>
<dt>Input</dt><dd>1, 2 or 3 integers (or 1 table), 1 value or 1 Array: indices(XYZ) of the element to set, default values are 1. Last argument is the new value. If the last argument is an array then all elements in the array are copied to the calling object.</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:setAll"><code>Array.Integer:setAll</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array to the given value</dd>
<dt>Input</dt><dd>1 Value: The new value for all element entries</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:sum"><code>Array.Integer:sum</code></a></h3>
<dl>
<dt>Description</dt><dd>Find sum of array</dd>
<dt>Output</dt><dd>1 value</dd>
</dl><hr>
<p>
<h3><a name="Array.Integer:zero"><code>Array.Integer:zero</code></a></h3>
<dl>
<dt>Description</dt><dd>Set all values in the array 0</dd>
</dl><hr>
<p>
<h2><a name="Dipole">Dipole</a></h2>
<p>
Calculates the dipolar field of a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>Dipole.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Dipole:apply"><code>Dipole:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Dipole:getArray"><code>Dipole:getArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get a named interaction matrix as an array</dd>
<dt>Input</dt><dd>1 string: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. </dd>
<dt>Output</dt><dd>1 Array: The interaction matrix for given AB components</dd>
</dl><hr>
<p>
<h3><a name="Dipole:getMatrix"><code>Dipole:getMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. Note: indexes are zero-based and are interpreted as offsets.</dd>
<dt>Output</dt><dd>1 number: The fetched value.</dd>
</dl><hr>
<p>
<h3><a name="Dipole:member"><code>Dipole:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Dipole:nx"><code>Dipole:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Dipole:ny"><code>Dipole:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Dipole:nz"><code>Dipole:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Dipole:scale"><code>Dipole:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setArray"><code>Dipole:setArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a named interaction matrix to a new array</dd>
<dt>Input</dt><dd>1 string, 1 Array: The string indicates which AB matrix to set. Can be XX, XY, XZ, YY, YZ or ZZ. The Array must be of appropriate dimensions</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setMatrix"><code>Dipole:setMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>, 1 number: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. The number is the value that is set at the index. Note: indexes are zero-based and are interpreted as offsets.</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setScale"><code>Dipole:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setStrength"><code>Dipole:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field</dd>
<dt>Input</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setTruncation"><code>Dipole:setTruncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the truncation distance in spins of the dipolar sum.</dd>
<dt>Input</dt><dd>1 Integer or Table of 3 Integers or 3 Integers: Radius of spins to sum out to. If set to math.huge then extrapolation will be used to approximate infinite radius. If input is more than 1 value then the input is considered as the hard truncation limit for each Cartesian coordinate.</dd>
</dl><hr>
<p>
<h3><a name="Dipole:setUnitCell"><code>Dipole:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell of a lattice site</dd>
<dt>Input</dt><dd>3 <a href="#3Vector">3Vector</a>: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h3><a name="Dipole:strength"><code>Dipole:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field</dd>
<dt>Output</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Dipole:truncation"><code>Dipole:truncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the truncation distance in spins of the dipolar sum.</dd>
<dt>Output</dt><dd>4 Integers: Radius of spins to sum out to, hard Limit in X, Y and Z direction.</dd>
</dl><hr>
<p>
<h3><a name="Dipole:unitCell"><code>Dipole:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell of a lattice site</dd>
<dt>Output</dt><dd>3 tables: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h2><a name="DipoleEwald3D">DipoleEwald3D</a></h2>
<p>
Object used to calculate individual elements of the dipolar interaction tensors
<p><dl><dt>DipoleEwald3D.new() takes the following arguments</dt><dd><a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: Optional lattice size</dd></dl>
<hr>
<p>
<h3><a name="DipoleEwald3D:NSites"><code>DipoleEwald3D:NSites</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the number of terms to use in the series along 1 direction in the 3D sum</dd>
<dt>Output</dt><dd>1 Number: The number of terms (initially 10)</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:calculateTensorElement"><code>DipoleEwald3D:calculateTensorElement</code></a></h3>
<dl>
<dt>Description</dt><dd>Calculate the tensor element.</dd>
<dt>Input</dt><dd>1 String, 1 <a href="#3Vector">3Vector</a>: String is AB pair (`XX', `XY', ..., `ZZ') the <a href="#3Vector">3Vector</a> represents offsets from zero. It takes 3 integer values each ranging from 0 to n-1 where n is the number of unit cells in the lattice in a given direction.</dd>
<dt>Output</dt><dd>1 Number: The tensor element at the requested position.</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:calculateTensorElementRealR"><code>DipoleEwald3D:calculateTensorElementRealR</code></a></h3>
<dl>
<dt>Description</dt><dd>Calculate the tensor element.</dd>
<dt>Input</dt><dd>1 String, 1 <a href="#3Vector">3Vector</a>: String is AB pair (`XX', `XY', ..., `ZZ') the <a href="#3Vector">3Vector</a> represents offsets from zero. It takes 3 real values representing a positon somewhere in the lattice. This 3D point is not transformed by the basis vectors.</dd>
<dt>Output</dt><dd>1 Number: The tensor element at the requested position.</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:eta"><code>DipoleEwald3D:eta</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the crossover eta value determined from search.</dd>
<dt>Output</dt><dd>1 Number: The crossover value eta</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:latticeSize"><code>DipoleEwald3D:latticeSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the number of unit cells in each crystallographic direction.</dd>
<dt>Output</dt><dd>3 Numbers: The number of unit cells in each crystallographic direction.</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:setLatticeSize"><code>DipoleEwald3D:setLatticeSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the number of unit cells in each crystallographic direction.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> or 1 <a href="#SpinSystem">SpinSystem</a>: The number of unit cells in each crystallographic direction.</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:setNSites"><code>DipoleEwald3D:setNSites</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the number of terms to use in the series along 1 direction in the 3D sum</dd>
<dt>Input</dt><dd>1 Number: The number of terms (initially 10)</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:setTau"><code>DipoleEwald3D:setTau</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the tolerance (tau) used in the search for a good eta value</dd>
<dt>Input</dt><dd>1 Number: The new tolerance value (initially 0.001)</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:setUnitCell"><code>DipoleEwald3D:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell for the tensor calculations</dd>
<dt>Input</dt><dd>3 <a href="#3Vector">3Vector</a>s: The a, b and c vectors making up the basis vectors for the unit cell,</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:tau"><code>DipoleEwald3D:tau</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the tolerance (tau) used in the search for a good eta value</dd>
<dt>Output</dt><dd>1 Number: The new tolerance value (initially 0.001)</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:unitCell"><code>DipoleEwald3D:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell for the tensor calculations</dd>
<dt>Output</dt><dd>3 Tables: The a, b and c vectors making up the basis vectors for the unit cell,</dd>
</dl><hr>
<p>
<h3><a name="DipoleEwald3D:volume"><code>DipoleEwald3D:volume</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the volume of the unit cell.</dd>
<dt>Output</dt><dd>1 Number: The volume.</dd>
</dl><hr>
<p>
<h2><a name="DisorderedDipole">DisorderedDipole</a></h2>
<p>
Calculates the dipolar field of a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>DisorderedDipole.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="DisorderedDipole:apply"><code>DisorderedDipole:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:arrayX"><code>DisorderedDipole:arrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the X components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The X components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:arrayY"><code>DisorderedDipole:arrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Y components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The Y components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:arrayZ"><code>DisorderedDipole:arrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Z components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The Z components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:member"><code>DisorderedDipole:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:nx"><code>DisorderedDipole:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:ny"><code>DisorderedDipole:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:nz"><code>DisorderedDipole:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:scale"><code>DisorderedDipole:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setArrayX"><code>DisorderedDipole:setArrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the X components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The X components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setArrayY"><code>DisorderedDipole:setArrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Y components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The Y components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setArrayZ"><code>DisorderedDipole:setArrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Z components site positions. This array is connected to the Operator so changes to the returned array will change operator.</dd>
<dt>Output</dt><dd>1 Array: The Z components of the positions.</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setScale"><code>DisorderedDipole:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setSitePosition"><code>DisorderedDipole:setSitePosition</code></a></h3>
<dl>
<dt>Description</dt><dd>Maps the lattice coordinate to a real world position</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s: First is lattice site, second is real world position</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:setStrength"><code>DisorderedDipole:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Dipolar Field</dd>
<dt>Input</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:sitePosition"><code>DisorderedDipole:sitePosition</code></a></h3>
<dl>
<dt>Description</dt><dd>Lookup the real world position from a lattice site</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Lattice site</dd>
<dt>Output</dt><dd>1 <a href="#3Vector">3Vector</a>: Real world postition</dd>
</dl><hr>
<p>
<h3><a name="DisorderedDipole:strength"><code>DisorderedDipole:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Dipolar Field</dd>
<dt>Output</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h2><a name="ElasticBand">ElasticBand</a></h2>
<p>
Calculate a minimum energy pathway between two states using an Elastic Band method.
<p><dl><dt>ElasticBand.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="ElasticBand:compute"><code>ElasticBand:compute</code></a></h3>
<dl>
<dt>Description</dt><dd>Run several relaxation steps of the elastic band method</dd>
<dt>Input</dt><dd>1 Optional Integer: Number of steps, default 50</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:energyFunction"><code>ElasticBand:energyFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the function used to determine system energy for the calculation.</dd>
<dt>Output</dt><dd>1 Function: energy calculation function, expected to be passed a <a href="#SpinSystem">SpinSystem</a>.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:getInternalData"><code>ElasticBand:getInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data. This method is used in the support lua scripts and should not be used.</dd>
<dt>Output</dt><dd>1 Value: the internal data</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:initialize"><code>ElasticBand:initialize</code></a></h3>
<dl>
<dt>Description</dt><dd>Expand the endpoints into a coherent rotation over the number of path points specified with setNumberOfPathPoints.</dd>
<dt>Input</dt><dd>1 Optional Number: The magnitude of the noise introduced in the first subdivision of the path the path into 3 points, default 0.05</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:numberOfPathPoints"><code>ElasticBand:numberOfPathPoints</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the number of path points used to approximate a line (defualt 20).</dd>
<dt>Output</dt><dd>1 Integer: Number of path points</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:numberOfSites"><code>ElasticBand:numberOfSites</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the number of sites used in calculation.</dd>
<dt>Output</dt><dd>1 Integer: Number of sites.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setEnergyFunction"><code>ElasticBand:setEnergyFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the function used to determine system energy for the calculation.</dd>
<dt>Input</dt><dd>1 Function: energy calculation function, expected to be passed a <a href="#SpinSystem">SpinSystem</a>.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setInitialPath"><code>ElasticBand:setInitialPath</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the initial path for the elastic band calculation</dd>
<dt>Input</dt><dd>1 Table of Tables of site orientations: Must be at least 2 elements long to define the start and end points. Example:<br> <pre>upup     = {{0,0,1},{0,0,1}}
downdown = {{0,0,-1},{0,0,-1}}
 eb:setInitialPath({upup,downdown})
</pre> </dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setInternalData"><code>ElasticBand:setInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data. This method is used in the support lua scripts and should not be used.</dd>
<dt>Input</dt><dd>1 Value: the new internal data</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setNumberOfPathPoints"><code>ElasticBand:setNumberOfPathPoints</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the number of path points used to approximate a line (defualt 20).</dd>
<dt>Input</dt><dd>1 Number: Number of path points</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setSites"><code>ElasticBand:setSites</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the sites that are allowed to move to transition from the initial configuration to the final configuration.</dd>
<dt>Input</dt><dd>1 Table of 1,2 or 3 Component Tables: mobile sites.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:setSpinSystem"><code>ElasticBand:setSpinSystem</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the SpinSystem that will be used to do energy and orientation calculations. The any changes made to this SpinSystem will be undone before control is returned to the calling environment.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>: SpinSystem to be used in calculations</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:sites"><code>ElasticBand:sites</code></a></h3>
<dl>
<dt>Description</dt><dd>Get which sites are involved in calculation</dd>
<dt>Output</dt><dd>1 Table of Tables of 3 Integers: Site positions involved in calculation.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:spin"><code>ElasticBand:spin</code></a></h3>
<dl>
<dt>Description</dt><dd>Get site x,y and z coordinates.</dd>
<dt>Input</dt><dd>2 Integers: 1st integer is path index, 2nd integer is site index.</dd>
<dt>Output</dt><dd>4 Numbers: x,y,z,m orientation of spin and magnitude at site s at path point p.</dd>
</dl><hr>
<p>
<h3><a name="ElasticBand:writePathPointTo"><code>ElasticBand:writePathPointTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Write path point to the given spin system</dd>
<dt>Input</dt><dd>1 Integer, 1 <a href="#SpinSystem">SpinSystem</a>: The integer ranges from 1 to the number of path points, the <a href="#SpinSystem">SpinSystem</a> will have the sites involved in the Elastic Band calculation changed to match those at the given path index.</dd>
</dl><hr>
<p>
<h2><a name="Exchange">Exchange</a></h2>
<p>
Calculates the exchange field of a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>Exchange.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Exchange:add"><code>Exchange:add</code></a></h3>
<dl>
<dt>Description</dt><dd>Add an exchange pathway between two sites.</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s, 1 Optional Number: The vectors define the lattice sites that share a pathway, the number is the strength of the pathway or 1 as a default. For example, if ex is an Exchange Operator then ex:addPath({1,1,1}, {1,1,2}, -1) and ex:addPath({1,1,2}, {1,1,1}, -1) would make two spins neighbours of each other with anti-ferromagnetic exchange.</dd>
</dl><hr>
<p>
<h3><a name="Exchange:addPath"><code>Exchange:addPath</code></a></h3>
<dl>
<dt>Description</dt><dd>Add an exchange pathway between two sites.</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s, 1 Optional Number: The vectors define the lattice sites that share a pathway, the number is the strength of the pathway or 1 as a default. For example, if ex is an Exchange Operator then ex:addPath({1,1,1}, {1,1,2}, -1) and ex:addPath({1,1,2}, {1,1,1}, -1) would make two spins neighbours of each other with anti-ferromagnetic exchange.</dd>
</dl><hr>
<p>
<h3><a name="Exchange:apply"><code>Exchange:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Exchange:member"><code>Exchange:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Exchange:mergePaths"><code>Exchange:mergePaths</code></a></h3>
<dl>
<dt>Description</dt><dd>Combine repeated to-from pairs into a single path with combined strength</dd>
</dl><hr>
<p>
<h3><a name="Exchange:numberOfPaths"><code>Exchange:numberOfPaths</code></a></h3>
<dl>
<dt>Description</dt><dd>Determine how many pathways exist in the operator</dd>
<dt>Output</dt><dd>1 Integer: Number of pathways</dd>
</dl><hr>
<p>
<h3><a name="Exchange:nx"><code>Exchange:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Exchange:ny"><code>Exchange:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Exchange:nz"><code>Exchange:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Exchange:path"><code>Exchange:path</code></a></h3>
<dl>
<dt>Description</dt><dd>Get information about a path</dd>
<dt>Input</dt><dd>1 Integer: Index of path [1:numberOfPaths()]</dd>
<dt>Output</dt><dd>2 Tables, 1 Number: triplets of integers describing from and to sites. 1 number describing strength</dd>
</dl><hr>
<p>
<h3><a name="Exchange:pathsFrom"><code>Exchange:pathsFrom</code></a></h3>
<dl>
<dt>Description</dt><dd>Get all path indices that connect from the given site</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Index of from-site</dd>
<dt>Output</dt><dd>1 Tables: indices of paths that connect from the given site</dd>
</dl><hr>
<p>
<h3><a name="Exchange:pathsTo"><code>Exchange:pathsTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Get all path indices that connect to the given site</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Index of to-site</dd>
<dt>Output</dt><dd>1 Tables: indices of paths that connect to the given site</dd>
</dl><hr>
<p>
<h3><a name="Exchange:periodicXYZ"><code>Exchange:periodicXYZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the flags for periodicity in the X, Y and Z directions. Default true, true, true.</dd>
<dt>Output</dt><dd>3 Booleans: Each value corresponds to a cardinal direction. If true then new paths will use periodic boundaries for out-of-range sites otherwise the path will be ignored.</dd>
</dl><hr>
<p>
<h3><a name="Exchange:scale"><code>Exchange:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Exchange:setPeriodicXYZ"><code>Exchange:setPeriodicXYZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the flags for periodicity in the X, Y and Z directions. Default true, true, true.</dd>
<dt>Input</dt><dd>3 Booleans: Each value corresponds to a cardinal direction. If true then new paths will use periodic boundaries for out-of-range sites otherwise the path will be ignored.</dd>
</dl><hr>
<p>
<h3><a name="Exchange:setScale"><code>Exchange:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h2><a name="Interpolate">Interpolate</a></h2>
<p>
Interpolate creates a 1D linear interpolating function
<p><dl><dt>Interpolate.new() takes the following arguments</dt><dd>1 Optional Table of Tables: A table of pairs can be passed into the .new function. Each pair will be effectively passed to the addData function.</dd></dl>
<hr>
<p>
<h3><a name="Interpolate:__call"><code>Interpolate:__call</code></a></h3>
<dl>
<dt>Description</dt><dd>Interpolate a value from the 1D linear interpolator.</dd>
<dt>Input</dt><dd>1 number: the x value or data position which will have a data value interpolated.</dd>
<dt>Output</dt><dd>1 number: the interpolated data value at the input position.</dd>
</dl><hr>
<p>
<h3><a name="Interpolate:addData"><code>Interpolate:addData</code></a></h3>
<dl>
<dt>Description</dt><dd>Add data to the 1D linear interpolator.</dd>
<dt>Input</dt><dd>2 numbers: the x and y values where x is the data position and y is the data value.</dd>
</dl><hr>
<p>
<h3><a name="Interpolate:maxX"><code>Interpolate:maxX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get maximum X value.</dd>
<dt>Output</dt><dd>1 Number: Maximum X value</dd>
</dl><hr>
<p>
<h3><a name="Interpolate:minX"><code>Interpolate:minX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get minimum X value.</dd>
<dt>Output</dt><dd>1 Number: Minimum X value</dd>
</dl><hr>
<p>
<h3><a name="Interpolate:value"><code>Interpolate:value</code></a></h3>
<dl>
<dt>Description</dt><dd>Interpolate a value from the 1D linear interpolator.</dd>
<dt>Input</dt><dd>1 number: the x value or data position which will have a data value interpolated.</dd>
<dt>Output</dt><dd>1 number: the interpolated data value at the input position.</dd>
</dl><hr>
<p>
<h2><a name="Interpolate2D">Interpolate2D</a></h2>
<p>
Interpolate2D creates a 2D linear interpolating function. Data must form a complete grid.
<p><dl><dt>Interpolate2D.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Interpolate2D:addData"><code>Interpolate2D:addData</code></a></h3>
<dl>
<dt>Description</dt><dd>Add data to the 2D linear interpolator.</dd>
<dt>Input</dt><dd>3 numbers: the x, y and z values where (x, y) is the data position and z is the data value.</dd>
</dl><hr>
<p>
<h3><a name="Interpolate2D:compile"><code>Interpolate2D:compile</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute all internal variables needed to interpolate a 2D value as well as data range. If this method is not called, it is done automatically when the first interpolated value is requested</dd>
</dl><hr>
<p>
<h3><a name="Interpolate2D:setInvalidValue"><code>Interpolate2D:setInvalidValue</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the value to return if a requested data point is outside the data range.</dd>
<dt>Input</dt><dd>1 number: Value of data outside data range</dd>
</dl><hr>
<p>
<h3><a name="Interpolate2D:validRange"><code>Interpolate2D:validRange</code></a></h3>
<dl>
<dt>Description</dt><dd>Compile the interpolating function if needed and return the valid data range of the interpolator.</dd>
<dt>Output</dt><dd>4 numbers: The xmin, xmax, ymin, ymax values</dd>
</dl><hr>
<p>
<h3><a name="Interpolate2D:value"><code>Interpolate2D:value</code></a></h3>
<dl>
<dt>Description</dt><dd>Interpolate a value from the 2D linear interpolator.</dd>
<dt>Input</dt><dd>2 numbers: the x and y value representing the data position which will have a value interpolated.</dd>
<dt>Output</dt><dd>1 number: the interpolated data value at the input position.</dd>
</dl><hr>
<p>
<h2><a name="LLG.Align">LLG.Align</a></h2>
<p>
LLG.Align dvances a <a href="#SpinSystem">SpinSystem</a> through time aligning spins with local fields
<p><dl><dt>LLG.Align.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="LLG.Align:apply"><code>LLG.Align:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 LLG Euler Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, Oprional Number, Optional 2 <a href="#SpinSystem">SpinSystem</a>s, Optional Boolean: Make 1 Euler step from 1st system using 2nd system to compute derivative (defaulting to 1st system), scaling timestep be optional number (default 1.0) and storing in 3rd system (defaulting to 1st system).If last argument is the boolean "false", the time will not be incremented</dd>
</dl><hr>
<p>
<h3><a name="LLG.Align:disableRenormalization"><code>LLG.Align:disableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Align:setDisableRenormalization"><code>LLG.Align:setDisableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 boolean (or default true): If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Align:setThermalOnlyFirstTerm"><code>LLG.Align:setThermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 Optional boolean: If true or none the thermal term in the effective field will only be applied to the precesional term of the LLG equation. If false then the thermal term will be used in both the precesional and damping terms. The default value for this variable is true this default can be changed by setting the base LLG table's `thermalOnlyFirstTerm' key to a boolean value. Example:<br> <pre>LLG.thermalOnlyFirstTerm = false
llg = LLG.Cartesian.new(ss)
print(llg:thermalOnlyFirstTerm())</pre> <br>Output:<br> <pre>false</pre> </dd>
</dl><hr>
<p>
<h3><a name="LLG.Align:thermalOnlyFirstTerm"><code>LLG.Align:thermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the thermal term is excluded from the damping term of the LLG equation, if false then the thermal term is used in both the precesional and damping terms.</dd>
</dl><hr>
<p>
<h2><a name="LLG.Base">LLG.Base</a></h2>
<p>
LLG advances a <a href="#SpinSystem">SpinSystem</a> through time using a form of the LLG equation. This is an abstract base class and is not intended to be used directly.
<p><dl><dt>LLG.Base.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="LLG.Base:apply"><code>LLG.Base:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 LLG Euler Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, Oprional Number, Optional 2 <a href="#SpinSystem">SpinSystem</a>s, Optional Boolean: Make 1 Euler step from 1st system using 2nd system to compute derivative (defaulting to 1st system), scaling timestep be optional number (default 1.0) and storing in 3rd system (defaulting to 1st system).If last argument is the boolean "false", the time will not be incremented</dd>
</dl><hr>
<p>
<h3><a name="LLG.Base:disableRenormalization"><code>LLG.Base:disableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Base:setDisableRenormalization"><code>LLG.Base:setDisableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 boolean (or default true): If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Base:setThermalOnlyFirstTerm"><code>LLG.Base:setThermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 Optional boolean: If true or none the thermal term in the effective field will only be applied to the precesional term of the LLG equation. If false then the thermal term will be used in both the precesional and damping terms. The default value for this variable is true this default can be changed by setting the base LLG table's `thermalOnlyFirstTerm' key to a boolean value. Example:<br> <pre>LLG.thermalOnlyFirstTerm = false
llg = LLG.Cartesian.new(ss)
print(llg:thermalOnlyFirstTerm())</pre> <br>Output:<br> <pre>false</pre> </dd>
</dl><hr>
<p>
<h3><a name="LLG.Base:thermalOnlyFirstTerm"><code>LLG.Base:thermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the thermal term is excluded from the damping term of the LLG equation, if false then the thermal term is used in both the precesional and damping terms.</dd>
</dl><hr>
<p>
<h2><a name="LLG.Cartesian">LLG.Cartesian</a></h2>
<p>
LLG.Cartesian advances a <a href="#SpinSystem">SpinSystem</a> through time using the Cartesian formulation of the LLG equation.
<p><dl><dt>LLG.Cartesian.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="LLG.Cartesian:apply"><code>LLG.Cartesian:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 LLG Euler Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, Oprional Number, Optional 2 <a href="#SpinSystem">SpinSystem</a>s, Optional Boolean: Make 1 Euler step from 1st system using 2nd system to compute derivative (defaulting to 1st system), scaling timestep be optional number (default 1.0) and storing in 3rd system (defaulting to 1st system).If last argument is the boolean "false", the time will not be incremented</dd>
</dl><hr>
<p>
<h3><a name="LLG.Cartesian:disableRenormalization"><code>LLG.Cartesian:disableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Cartesian:setDisableRenormalization"><code>LLG.Cartesian:setDisableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 boolean (or default true): If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Cartesian:setThermalOnlyFirstTerm"><code>LLG.Cartesian:setThermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 Optional boolean: If true or none the thermal term in the effective field will only be applied to the precesional term of the LLG equation. If false then the thermal term will be used in both the precesional and damping terms. The default value for this variable is true this default can be changed by setting the base LLG table's `thermalOnlyFirstTerm' key to a boolean value. Example:<br> <pre>LLG.thermalOnlyFirstTerm = false
llg = LLG.Cartesian.new(ss)
print(llg:thermalOnlyFirstTerm())</pre> <br>Output:<br> <pre>false</pre> </dd>
</dl><hr>
<p>
<h3><a name="LLG.Cartesian:thermalOnlyFirstTerm"><code>LLG.Cartesian:thermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the thermal term is excluded from the damping term of the LLG equation, if false then the thermal term is used in both the precesional and damping terms.</dd>
</dl><hr>
<p>
<h2><a name="LLG.Fake">LLG.Fake</a></h2>
<p>
LLG.Fake advances a <a href="#SpinSystem">SpinSystem</a> through time without changing spin orientation
<p><dl><dt>LLG.Fake.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="LLG.Fake:apply"><code>LLG.Fake:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 LLG Euler Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, Oprional Number, Optional 2 <a href="#SpinSystem">SpinSystem</a>s, Optional Boolean: Make 1 Euler step from 1st system using 2nd system to compute derivative (defaulting to 1st system), scaling timestep be optional number (default 1.0) and storing in 3rd system (defaulting to 1st system).If last argument is the boolean "false", the time will not be incremented</dd>
</dl><hr>
<p>
<h3><a name="LLG.Fake:disableRenormalization"><code>LLG.Fake:disableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Fake:setDisableRenormalization"><code>LLG.Fake:setDisableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 boolean (or default true): If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Fake:setThermalOnlyFirstTerm"><code>LLG.Fake:setThermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 Optional boolean: If true or none the thermal term in the effective field will only be applied to the precesional term of the LLG equation. If false then the thermal term will be used in both the precesional and damping terms. The default value for this variable is true this default can be changed by setting the base LLG table's `thermalOnlyFirstTerm' key to a boolean value. Example:<br> <pre>LLG.thermalOnlyFirstTerm = false
llg = LLG.Cartesian.new(ss)
print(llg:thermalOnlyFirstTerm())</pre> <br>Output:<br> <pre>false</pre> </dd>
</dl><hr>
<p>
<h3><a name="LLG.Fake:thermalOnlyFirstTerm"><code>LLG.Fake:thermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the thermal term is excluded from the damping term of the LLG equation, if false then the thermal term is used in both the precesional and damping terms.</dd>
</dl><hr>
<p>
<h2><a name="LLG.Quaternion">LLG.Quaternion</a></h2>
<p>
LLG.Quaternion advances a <a href="#SpinSystem">SpinSystem</a> through time using the Quaternion formulation of the LLG equation.
<p><dl><dt>LLG.Quaternion.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="LLG.Quaternion:apply"><code>LLG.Quaternion:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 LLG Euler Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, Oprional Number, Optional 2 <a href="#SpinSystem">SpinSystem</a>s, Optional Boolean: Make 1 Euler step from 1st system using 2nd system to compute derivative (defaulting to 1st system), scaling timestep be optional number (default 1.0) and storing in 3rd system (defaulting to 1st system).If last argument is the boolean "false", the time will not be incremented</dd>
</dl><hr>
<p>
<h3><a name="LLG.Quaternion:disableRenormalization"><code>LLG.Quaternion:disableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Quaternion:setDisableRenormalization"><code>LLG.Quaternion:setDisableRenormalization</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 boolean (or default true): If true then the x,y,z coordinates of each spin are not renormalized to the original length of the spin.</dd>
</dl><hr>
<p>
<h3><a name="LLG.Quaternion:setThermalOnlyFirstTerm"><code>LLG.Quaternion:setThermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data for algorithm interpretation.</dd>
<dt>Input</dt><dd>1 Optional boolean: If true or none the thermal term in the effective field will only be applied to the precesional term of the LLG equation. If false then the thermal term will be used in both the precesional and damping terms. The default value for this variable is true this default can be changed by setting the base LLG table's `thermalOnlyFirstTerm' key to a boolean value. Example:<br> <pre>LLG.thermalOnlyFirstTerm = false
llg = LLG.Cartesian.new(ss)
print(llg:thermalOnlyFirstTerm())</pre> <br>Output:<br> <pre>false</pre> </dd>
</dl><hr>
<p>
<h3><a name="LLG.Quaternion:thermalOnlyFirstTerm"><code>LLG.Quaternion:thermalOnlyFirstTerm</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data for algorithm interpretation.</dd>
<dt>Output</dt><dd>1 boolean: If true then the thermal term is excluded from the damping term of the LLG equation, if false then the thermal term is used in both the precesional and damping terms.</dd>
</dl><hr>
<p>
<h2><a name="LongRange">LongRange</a></h2>
<p>
Calculates a Long Range field for a <a href="#SpinSystem">SpinSystem</a>. This is an abstract base class inherited by other operators. This operator by itself does nothing.
<p><dl><dt>LongRange.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="LongRange:apply"><code>LongRange:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="LongRange:getArray"><code>LongRange:getArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get a named interaction matrix as an array</dd>
<dt>Input</dt><dd>1 string: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. </dd>
<dt>Output</dt><dd>1 Array: The interaction matrix for given AB components</dd>
</dl><hr>
<p>
<h3><a name="LongRange:getMatrix"><code>LongRange:getMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. Note: indexes are zero-based and are interpreted as offsets.</dd>
<dt>Output</dt><dd>1 number: The fetched value.</dd>
</dl><hr>
<p>
<h3><a name="LongRange:member"><code>LongRange:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="LongRange:nx"><code>LongRange:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange:ny"><code>LongRange:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange:nz"><code>LongRange:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange:scale"><code>LongRange:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setArray"><code>LongRange:setArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a named interaction matrix to a new array</dd>
<dt>Input</dt><dd>1 string, 1 Array: The string indicates which AB matrix to set. Can be XX, XY, XZ, YY, YZ or ZZ. The Array must be of appropriate dimensions</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setMatrix"><code>LongRange:setMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>, 1 number: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. The number is the value that is set at the index. Note: indexes are zero-based and are interpreted as offsets.</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setScale"><code>LongRange:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setStrength"><code>LongRange:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field</dd>
<dt>Input</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setTruncation"><code>LongRange:setTruncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the truncation distance in spins of the dipolar sum.</dd>
<dt>Input</dt><dd>1 Integer or Table of 3 Integers or 3 Integers: Radius of spins to sum out to. If set to math.huge then extrapolation will be used to approximate infinite radius. If input is more than 1 value then the input is considered as the hard truncation limit for each Cartesian coordinate.</dd>
</dl><hr>
<p>
<h3><a name="LongRange:setUnitCell"><code>LongRange:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell of a lattice site</dd>
<dt>Input</dt><dd>3 <a href="#3Vector">3Vector</a>: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h3><a name="LongRange:strength"><code>LongRange:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field</dd>
<dt>Output</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="LongRange:truncation"><code>LongRange:truncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the truncation distance in spins of the dipolar sum.</dd>
<dt>Output</dt><dd>4 Integers: Radius of spins to sum out to, hard Limit in X, Y and Z direction.</dd>
</dl><hr>
<p>
<h3><a name="LongRange:unitCell"><code>LongRange:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell of a lattice site</dd>
<dt>Output</dt><dd>3 tables: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h2><a name="LongRange2D">LongRange2D</a></h2>
<p>
Calculates a Long Range field for a <a href="#SpinSystem">SpinSystem</a>. This is a base class used by other operators. This operator by itself does nothing.
<p><dl><dt>LongRange2D.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="LongRange2D:apply"><code>LongRange2D:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:internalData"><code>LongRange2D:internalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data used to build tensors</dd>
<dt>Output</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:makeData"><code>LongRange2D:makeData</code></a></h3>
<dl>
<dt>Description</dt><dd>Generates new internal data if required</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:makeDataFunction"><code>LongRange2D:makeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal function used to build tensors</dd>
<dt>Output</dt><dd>1 function: argument of function should be a LongRange2D object</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:member"><code>LongRange2D:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:nx"><code>LongRange2D:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:ny"><code>LongRange2D:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:nz"><code>LongRange2D:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:scale"><code>LongRange2D:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setCompileRequired"><code>LongRange2D:setCompileRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal compile required state. Must be set to true if any of the interaction tensors were modified.</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal flag state</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setInternalData"><code>LongRange2D:setInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data used to build tensors</dd>
<dt>Input</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setMakeDataFunction"><code>LongRange2D:setMakeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal function used to build tensors</dd>
<dt>Input</dt><dd>1 function: argument of function should be a LongRange2D object</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setNewDataRequired"><code>LongRange2D:setNewDataRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal new data required state. This is used in some internal routines where the data is set manually rather than calculated</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal data required flag state</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setScale"><code>LongRange2D:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setStrength"><code>LongRange2D:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field at a given layer</dd>
<dt>Input</dt><dd>1 Integer, 1 number: strength of the field at layer</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:setTensorArray"><code>LongRange2D:setTensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the tensor array for one layer interacting with another. Layers indices are base 1.</dd>
<dt>Input</dt><dd>1 Integer, 1 Integer, 1 String, 1 Array: Destination layer, Source Layer, Tensor name and array.</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:strength"><code>LongRange2D:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field at a given layer</dd>
<dt>Input</dt><dd>1 Integer: Layer</dd>
<dt>Output</dt><dd>1 Number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="LongRange2D:tensorArray"><code>LongRange2D:tensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the tensor array for one layer interacting with another. Layers indices are base 1.</dd>
<dt>Input</dt><dd>1 Integer, 1 Integer, 1 String: Destination layer, Source Layer, Tensor name.</dd>
<dt>Output</dt><dd>1 Array: Tensor</dd>
</dl><hr>
<p>
<h2><a name="LongRange3D">LongRange3D</a></h2>
<p>
Calculates a Long Range field for a <a href="#SpinSystem">SpinSystem</a>. This is a base class used by other operators. This operator by itself does nothing.
<p><dl><dt>LongRange3D.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="LongRange3D:apply"><code>LongRange3D:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:internalData"><code>LongRange3D:internalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data used to build tensors</dd>
<dt>Output</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:loadTensors"><code>LongRange3D:loadTensors</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience method to load interaction tensors from a file</dd>
<dt>Input</dt><dd>1 String: The filename of the tensor file.</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:makeData"><code>LongRange3D:makeData</code></a></h3>
<dl>
<dt>Description</dt><dd>Generates new internal data if required</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:makeDataFunction"><code>LongRange3D:makeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal function used to build tensors</dd>
<dt>Output</dt><dd>1 function: argument of function should be a LongRange3D object</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:member"><code>LongRange3D:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:nx"><code>LongRange3D:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:ny"><code>LongRange3D:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:nz"><code>LongRange3D:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:saveTensors"><code>LongRange3D:saveTensors</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience method to save the tensors in a lua readable file</dd>
<dt>Input</dt><dd>2 Strings: The filename used for writing the tensor file, traditionally ending with a .lua extension. Optional note to put in the file.</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:scale"><code>LongRange3D:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setCompileRequired"><code>LongRange3D:setCompileRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal compile required state. Must be set to true if any of the interaction tensors were modified.</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal flag state</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setInternalData"><code>LongRange3D:setInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data used to build tensors</dd>
<dt>Input</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setMakeDataFunction"><code>LongRange3D:setMakeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal function used to build tensors</dd>
<dt>Input</dt><dd>1 function: argument of function should be a LongRange3D object</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setMatrix"><code>LongRange3D:setMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a tensor element</dd>
<dt>Input</dt><dd>1 String, 3 Numbers or 1 Table of 3 Numbers, 1 Number: Tensor name, base 0 element coordinate in the tensor, new value</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setNewDataRequired"><code>LongRange3D:setNewDataRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal new data required state. This is used in some internal routines where the data is set manually rather than calculated</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal data required flag state</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setScale"><code>LongRange3D:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setStrength"><code>LongRange3D:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field </dd>
<dt>Input</dt><dd>1 Number: Strength of the field</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:setTensorArray"><code>LongRange3D:setTensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the tensor array.</dd>
<dt>Input</dt><dd>1 String, 1 Array: Tensor name and array.</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:strength"><code>LongRange3D:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field at a given layer</dd>
<dt>Output</dt><dd>1 Number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="LongRange3D:tensorArray"><code>LongRange3D:tensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the tensor array.</dd>
<dt>Input</dt><dd>1 String: Tensor name ("XX", "XY", ... "ZZ").</dd>
<dt>Output</dt><dd>1 Array: Tensor</dd>
</dl><hr>
<p>
<h2><a name="Magnetostatic">Magnetostatic</a></h2>
<p>
DEPRECIATED: Please transition to <a href="#Magnetostatics2D">Magnetostatics2D</a>. Calculates the magnetostatic field of a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>Magnetostatic.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Magnetostatic:apply"><code>Magnetostatic:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:cellDimensions"><code>Magnetostatic:cellDimensions</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the dimension of each Rectangular Prism</dd>
<dt>Output</dt><dd>3 Numbers: The x, y and z lengths of the prism</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:crossoverTolerance"><code>Magnetostatic:crossoverTolerance</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the relative error to define the crossover from magnetostatics to dipole calculations in the interaction matrix generation. Initial value is 0.0001.</dd>
<dt>Input</dt><dd>1 Number: The relative error for the crossover</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:getArray"><code>Magnetostatic:getArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get a named interaction matrix as an array</dd>
<dt>Input</dt><dd>1 string: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. </dd>
<dt>Output</dt><dd>1 Array: The interaction matrix for given AB components</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:getMatrix"><code>Magnetostatic:getMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. Note: indexes are zero-based and are interpreted as offsets.</dd>
<dt>Output</dt><dd>1 number: The fetched value.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:member"><code>Magnetostatic:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:nx"><code>Magnetostatic:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:ny"><code>Magnetostatic:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:nz"><code>Magnetostatic:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:scale"><code>Magnetostatic:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setArray"><code>Magnetostatic:setArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a named interaction matrix to a new array</dd>
<dt>Input</dt><dd>1 string, 1 Array: The string indicates which AB matrix to set. Can be XX, XY, XZ, YY, YZ or ZZ. The Array must be of appropriate dimensions</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setCellDimensions"><code>Magnetostatic:setCellDimensions</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the dimension of each Rectangular Prism</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The x, y and z lengths of the prism</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setCrossoverTolerance"><code>Magnetostatic:setCrossoverTolerance</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the relative error to define the crossover from magnetostatics to dipole calculations in the interaction matrix generation. Initial value is 0.0001.</dd>
<dt>Input</dt><dd>1 Number: The relative error for the crossover</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setMatrix"><code>Magnetostatic:setMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an element of an interaction matrix</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#3Vector">3Vector</a>, 1 number: The string indicates which AB matrix to access. Can be XX, XY, XZ, YY, YZ or ZZ. The <a href="#3Vector">3Vector</a> indexes into the matrix. The number is the value that is set at the index. Note: indexes are zero-based and are interpreted as offsets.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setScale"><code>Magnetostatic:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setStrength"><code>Magnetostatic:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field</dd>
<dt>Input</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setTruncation"><code>Magnetostatic:setTruncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the truncation distance in spins of the dipolar sum.</dd>
<dt>Input</dt><dd>1 Integer or Table of 3 Integers or 3 Integers: Radius of spins to sum out to. If set to math.huge then extrapolation will be used to approximate infinite radius. If input is more than 1 value then the input is considered as the hard truncation limit for each Cartesian coordinate.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:setUnitCell"><code>Magnetostatic:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell of a lattice site</dd>
<dt>Input</dt><dd>3 <a href="#3Vector">3Vector</a>: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:strength"><code>Magnetostatic:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field</dd>
<dt>Output</dt><dd>1 number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:truncation"><code>Magnetostatic:truncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the truncation distance in spins of the dipolar sum.</dd>
<dt>Output</dt><dd>4 Integers: Radius of spins to sum out to, hard Limit in X, Y and Z direction.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatic:unitCell"><code>Magnetostatic:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell of a lattice site</dd>
<dt>Output</dt><dd>3 tables: The A, B and C vectors defining the unit cell. By default, this is {1,0,0},{0,1,0},{0,0,1} or a cubic system.</dd>
</dl><hr>
<p>
<h2><a name="Magnetostatics2D">Magnetostatics2D</a></h2>
<p>
Calculates a Long Range Magnetostatic field for a <a href="#SpinSystem">SpinSystem</a>.
<p><dl><dt>Magnetostatics2D.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Magnetostatics2D:apply"><code>Magnetostatics2D:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:getMatrix"><code>Magnetostatics2D:getMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element of the interaction tensor</dd>
<dt>Input</dt><dd>2 Integers, 1 String, 2 Integers: destination layer (base 1), source layer (base 1), tensor name: (XX, XY, XZ, YX,...), x and y offset, </dd>
<dt>Output</dt><dd>1 Number: Tensor element</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:grainSize"><code>Magnetostatics2D:grainSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the grain size of the prism for a given layer.</dd>
<dt>Input</dt><dd>1 Integer:  Layer number to get (base 1). </dd>
<dt>Output</dt><dd>3 Numbers: The X, Y and Z dimension of the prism at that layer.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:internalData"><code>Magnetostatics2D:internalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data used to build tensors</dd>
<dt>Output</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:makeData"><code>Magnetostatics2D:makeData</code></a></h3>
<dl>
<dt>Description</dt><dd>Generates new internal data if required</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:makeDataFunction"><code>Magnetostatics2D:makeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal function used to build tensors</dd>
<dt>Output</dt><dd>1 function: argument of function should be a LongRange2D object</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:member"><code>Magnetostatics2D:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:nx"><code>Magnetostatics2D:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:ny"><code>Magnetostatics2D:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:nz"><code>Magnetostatics2D:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:scale"><code>Magnetostatics2D:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setCompileRequired"><code>Magnetostatics2D:setCompileRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal compile required state. Must be set to true if any of the interaction tensors were modified.</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal flag state</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setGrainSize"><code>Magnetostatics2D:setGrainSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the grain size of the prism for a given layer.</dd>
<dt>Input</dt><dd>1 Integer, 3 Numbers: Layer number to set (base 1) and the X, Y and Z dimension of the prism at that layer.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setInternalData"><code>Magnetostatics2D:setInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data used to build tensors</dd>
<dt>Input</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setMakeDataFunction"><code>Magnetostatics2D:setMakeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal function used to build tensors</dd>
<dt>Input</dt><dd>1 function: argument of function should be a LongRange2D object</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setNewDataRequired"><code>Magnetostatics2D:setNewDataRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal new data required state. This is used in some internal routines where the data is set manually rather than calculated</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal data required flag state</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setScale"><code>Magnetostatics2D:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setStrength"><code>Magnetostatics2D:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field at a given layer</dd>
<dt>Input</dt><dd>1 Integer, 1 number: strength of the field at layer</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setTensorArray"><code>Magnetostatics2D:setTensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the tensor array for one layer interacting with another. Layers indices are base 1.</dd>
<dt>Input</dt><dd>1 Integer, 1 Integer, 1 String, 1 Array: Destination layer, Source Layer, Tensor name and array.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setTruncation"><code>Magnetostatics2D:setTruncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the truncation site radii in the tensor generation</dd>
<dt>Input</dt><dd>Up to 4 Integers: Radial truncation, truncation in X direction, truncation in Y, truncation in Z</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:setUnitCell"><code>Magnetostatics2D:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell dimensions for one of the layers.</dd>
<dt>Input</dt><dd>1 Integer, 3 Tables of 3 Numbers: Layer number to set (base 1) and the unit cell vectors of that layer.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:strength"><code>Magnetostatics2D:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field at a given layer</dd>
<dt>Input</dt><dd>1 Integer: Layer</dd>
<dt>Output</dt><dd>1 Number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:tensorArray"><code>Magnetostatics2D:tensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the tensor array for one layer interacting with another. Layers indices are base 1.</dd>
<dt>Input</dt><dd>1 Integer, 1 Integer, 1 String: Destination layer, Source Layer, Tensor name.</dd>
<dt>Output</dt><dd>1 Array: Tensor</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:truncation"><code>Magnetostatics2D:truncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the truncation site radii in the tensor generation</dd>
<dt>Output</dt><dd>Integers: Radial truncation, truncation in X direction, truncation in Y, truncation in Z</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics2D:unitCell"><code>Magnetostatics2D:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell dimensions for one of the layers.</dd>
<dt>Input</dt><dd>1 Integer: Layer number to get (base 1).</dd>
<dt>Output</dt><dd>3 Tables of 3 Numbers: The unit cell vectors of that layer</dd>
</dl><hr>
<p>
<h2><a name="Magnetostatics3D">Magnetostatics3D</a></h2>
<p>
Calculates a Long Range Magnetostatic field for a <a href="#SpinSystem">SpinSystem</a>.
<p><dl><dt>Magnetostatics3D.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="Magnetostatics3D:apply"><code>Magnetostatics3D:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Apply the operator to the SpinSystem</dd>
<dt>Input</dt><dd>1 SpinSystem: System that will receive the resulting fields</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:getMatrix"><code>Magnetostatics3D:getMatrix</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an element of the interaction tensor</dd>
<dt>Input</dt><dd>1 String, 3 Integers: tensor name: (XX, XY, XZ, YX,...), x, y and z offset, </dd>
<dt>Output</dt><dd>1 Number: Tensor element</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:grainSize"><code>Magnetostatics3D:grainSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the grain size of the prism.</dd>
<dt>Output</dt><dd>3 Numbers: The X, Y and Z dimension of the prism.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:internalData"><code>Magnetostatics3D:internalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal data used to build tensors</dd>
<dt>Output</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:makeData"><code>Magnetostatics3D:makeData</code></a></h3>
<dl>
<dt>Description</dt><dd>Generates new internal data if required</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:makeDataFunction"><code>Magnetostatics3D:makeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Get internal function used to build tensors</dd>
<dt>Output</dt><dd>1 function: argument of function should be a LongRange3D object</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:member"><code>Magnetostatics3D:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:nx"><code>Magnetostatics3D:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:ny"><code>Magnetostatics3D:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:nz"><code>Magnetostatics3D:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:scale"><code>Magnetostatics3D:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setCompileRequired"><code>Magnetostatics3D:setCompileRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal compile required state. Must be set to true if any of the interaction tensors were modified.</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal flag state</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setGrainSize"><code>Magnetostatics3D:setGrainSize</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the grain size of the prism.</dd>
<dt>Input</dt><dd>3 Numbers: The X, Y and Z dimension of the prism.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setInternalData"><code>Magnetostatics3D:setInternalData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal data used to build tensors</dd>
<dt>Input</dt><dd>1 value: usually a table holding data</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setMakeDataFunction"><code>Magnetostatics3D:setMakeDataFunction</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal function used to build tensors</dd>
<dt>Input</dt><dd>1 function: argument of function should be a LongRange3D object</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setNewDataRequired"><code>Magnetostatics3D:setNewDataRequired</code></a></h3>
<dl>
<dt>Description</dt><dd>Set internal new data required state. This is used in some internal routines where the data is set manually rather than calculated</dd>
<dt>Input</dt><dd>1 Optional Boolean (default true): new internal data required flag state</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setScale"><code>Magnetostatics3D:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setStrength"><code>Magnetostatics3D:setStrength</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the strength of the Long Range Field </dd>
<dt>Input</dt><dd>1 Number: Strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setTensorArray"><code>Magnetostatics3D:setTensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the tensor array.</dd>
<dt>Input</dt><dd>1 String, 1 Array: Tensor name and array.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setTruncation"><code>Magnetostatics3D:setTruncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the truncation site radii in the tensor generation</dd>
<dt>Input</dt><dd>Up to 4 Integers: Radial truncation, truncation in X direction, truncation in Y, truncation in Z</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:setUnitCell"><code>Magnetostatics3D:setUnitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the unit cell dimensions.</dd>
<dt>Input</dt><dd>3 Tables of 3 Numbers: Unit cell vectors.</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:strength"><code>Magnetostatics3D:strength</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the strength of the Long Range Field at a given layer</dd>
<dt>Output</dt><dd>1 Number: strength of the field</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:tensorArray"><code>Magnetostatics3D:tensorArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the tensor array.</dd>
<dt>Input</dt><dd>1 String: Tensor name ("XX", "XY", ... "ZZ").</dd>
<dt>Output</dt><dd>1 Array: Tensor</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:truncation"><code>Magnetostatics3D:truncation</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the truncation site radii in the tensor generation</dd>
<dt>Output</dt><dd>Integers: Radial truncation, truncation in X direction, truncation in Y, truncation in Z</dd>
</dl><hr>
<p>
<h3><a name="Magnetostatics3D:unitCell"><code>Magnetostatics3D:unitCell</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the unit cell dimensions.</dd>
<dt>Output</dt><dd>3 Tables of 3 Numbers: The unit cell vectors.</dd>
</dl><hr>
<p>
<h2><a name="Random.Base">Random.Base</a></h2>
<p>
Random number generator abstract base class
<p><dl><dt>Random.Base.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Random.Base:normal"><code>Random.Base:normal</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a normal distribution</dd>
<dt>Output</dt><dd>1 number: A random normal number selected for a normal distribution with stddev 1 and mean 0.</dd>
</dl><hr>
<p>
<h3><a name="Random.Base:rand"><code>Random.Base:rand</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h3><a name="Random.Base:setSeed"><code>Random.Base:setSeed</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the seed for the random number generator</dd>
<dt>Input</dt><dd>1 integer: This will be used as the seed for the RNG.</dd>
</dl><hr>
<p>
<h3><a name="Random.Base:uniform"><code>Random.Base:uniform</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h2><a name="Random.CRand">Random.CRand</a></h2>
<p>
Random.CRand generates random variables using the C Library RNG.
<p><dl><dt>Random.CRand.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Random.CRand:normal"><code>Random.CRand:normal</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a normal distribution</dd>
<dt>Output</dt><dd>1 number: A random normal number selected for a normal distribution with stddev 1 and mean 0.</dd>
</dl><hr>
<p>
<h3><a name="Random.CRand:rand"><code>Random.CRand:rand</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h3><a name="Random.CRand:setSeed"><code>Random.CRand:setSeed</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the seed for the random number generator</dd>
<dt>Input</dt><dd>1 integer: This will be used as the seed for the RNG.</dd>
</dl><hr>
<p>
<h3><a name="Random.CRand:uniform"><code>Random.CRand:uniform</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h2><a name="Random.Isaac">Random.Isaac</a></h2>
<p>
Random.Isaac generates random variables using Bob Jenkins's RNG.
<p><dl><dt>Random.Isaac.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Random.Isaac:normal"><code>Random.Isaac:normal</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a normal distribution</dd>
<dt>Output</dt><dd>1 number: A random normal number selected for a normal distribution with stddev 1 and mean 0.</dd>
</dl><hr>
<p>
<h3><a name="Random.Isaac:rand"><code>Random.Isaac:rand</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h3><a name="Random.Isaac:setSeed"><code>Random.Isaac:setSeed</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the seed for the random number generator</dd>
<dt>Input</dt><dd>1 integer: This will be used as the seed for the RNG.</dd>
</dl><hr>
<p>
<h3><a name="Random.Isaac:uniform"><code>Random.Isaac:uniform</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h2><a name="Random.MersenneTwister">Random.MersenneTwister</a></h2>
<p>
Random.MersenneTwister generates random variables using the Mersenne Twister. Mersenne Twister random number generator -- a C++ class MTRand. Based on code by Makoto Matsumoto, Takuji Nishimura, and Shawn Cokus. Richard J. Wagner  v1.1  28 September 2009  wagnerr@umich.edu
<p><dl><dt>Random.MersenneTwister.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Random.MersenneTwister:normal"><code>Random.MersenneTwister:normal</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a normal distribution</dd>
<dt>Output</dt><dd>1 number: A random normal number selected for a normal distribution with stddev 1 and mean 0.</dd>
</dl><hr>
<p>
<h3><a name="Random.MersenneTwister:rand"><code>Random.MersenneTwister:rand</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h3><a name="Random.MersenneTwister:setSeed"><code>Random.MersenneTwister:setSeed</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the seed for the random number generator</dd>
<dt>Input</dt><dd>1 integer: This will be used as the seed for the RNG.</dd>
</dl><hr>
<p>
<h3><a name="Random.MersenneTwister:uniform"><code>Random.MersenneTwister:uniform</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a value selected from a uniform distribution</dd>
<dt>Input</dt><dd>1 Optional number:</dd>
<dt>Output</dt><dd>1 number: A random uniform number in the range of [0:1] if for no optional value or [0:n] for an optional argument n</dd>
</dl><hr>
<p>
<h2><a name="SQLite3">SQLite3</a></h2>
<p>
SQLite3 database interaction object
<p><dl><dt>SQLite3.new() takes the following arguments</dt><dd>1 String: Filename of the database to open or create.</dd></dl>
<hr>
<p>
<h3><a name="SQLite3:bootstrap"><code>SQLite3:bootstrap</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience method to execute the default bootstrap action on a database. The following function is interpreted as a method:<br> <pre>function bootstrap(sql)
	local res = sql:exec("SELECT code FROM Bootstrap;")
	local code = res[table.maxn(res)]["code"]
	local g = loadstring(code)
	g() --load init into scope
	return init(sql)
end</pre> <br></dd>
<dt>Output</dt><dd>The return values from the init function.</dd>
</dl><hr>
<p>
<h3><a name="SQLite3:changes"><code>SQLite3:changes</code></a></h3>
<dl>
<dt>Description</dt><dd>Determine how many records were changed by the most recent SQL operation</dd>
<dt>Output</dt><dd>1 Integer: Number of records changed.</dd>
</dl><hr>
<p>
<h3><a name="SQLite3:close"><code>SQLite3:close</code></a></h3>
<dl>
<dt>Description</dt><dd>Close the opened SQLite3 database</dd>
</dl><hr>
<p>
<h3><a name="SQLite3:escapeString"><code>SQLite3:escapeString</code></a></h3>
<dl>
<dt>Description</dt><dd>Escape quotes in a string so that it may be used in an SQL statement</dd>
<dt>Input</dt><dd>1 String: Unescaped string.</dd>
<dt>Output</dt><dd>1 String: Escaped string.</dd>
</dl><hr>
<p>
<h3><a name="SQLite3:exec"><code>SQLite3:exec</code></a></h3>
<dl>
<dt>Description</dt><dd>Execute a properly formatted SQLite3 instruction</dd>
<dt>Input</dt><dd>1 String: SQL instruction</dd>
<dt>Output</dt><dd>1 Table: Result of the operation.</dd>
</dl><hr>
<p>
<h3><a name="SQLite3:setupBootstrap"><code>SQLite3:setupBootstrap</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience method setup the default bootstrap action on a database</dd>
<dt>Input</dt><dd>1 Function: The function's code is added to the database the function name is expected to be "init" and will be passed the database on function call. The following function is interpreted as a method:<br> <pre>local function setupBootstrap(sql, f)
	sql:exec([[
		CREATE TABLE IF NOT EXISTS Bootstrap(version INTEGER PRIMARY KEY, code TEXT);
	]])
	
	local src = get_src(f)
	ee = "INSERT INTO Bootstrap VALUES(NULL,  '" .. sql:escapeString(src) .. "' );"
	sql:exec(ee)
	
end</pre> <br></dd>
</dl><hr>
<p>
<h2><a name="SpinSystem">SpinSystem</a></h2>
<p>
Represents and contains a lattice of spins including orientation and resulting fields.
<p><dl><dt>SpinSystem.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>: System Size</dd></dl>
<hr>
<p>
<h3><a name="SpinSystem:addFields"><code>SpinSystem:addFields</code></a></h3>
<dl>
<dt>Description</dt><dd>Add fields from one <a href="#SpinSystem">SpinSystem</a> to the current one, optionally scaling the field.</dd>
<dt>Input</dt><dd>1 Optional Number, 1 <a href="#SpinSystem">SpinSystem</a>: The fields in the spin system are added to the calling spin system multiplied by the optional scaling value. This is useful when implementing higher order integrators.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:alpha"><code>SpinSystem:alpha</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the damping value for the spin system. This is used in <a href="#LLG">LLG</a> routines as well as <a href="#Thermal">Thermal</a> calculations.</dd>
<dt>Output</dt><dd>1 Number: The damping value.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:copy"><code>SpinSystem:copy</code></a></h3>
<dl>
<dt>Description</dt><dd>Create a new copy of the spinsystem.</dd>
<dt>Output</dt><dd>1 <a href="#SpinSystem">SpinSystem</a></dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:copyFieldTo"><code>SpinSystem:copyFieldTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Copy a field type of the calling <a href="#SpinSystem">SpinSystem</a> to the given system.</dd>
<dt>Input</dt><dd>1 string, 1 <a href="#SpinSystem">SpinSystem</a>: Field name, destination spin system.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:copyFieldsTo"><code>SpinSystem:copyFieldsTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Copy fields of the calling <a href="#SpinSystem">SpinSystem</a> to the given system.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>: Destination spin system.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:copySpinsTo"><code>SpinSystem:copySpinsTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Copy spins of the calling <a href="#SpinSystem">SpinSystem</a> to the given system.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>: Destination spin system.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:copyTo"><code>SpinSystem:copyTo</code></a></h3>
<dl>
<dt>Description</dt><dd>Copy all aspects of the calling <a href="#SpinSystem">SpinSystem</a> to the given system.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>: Destination spin system.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:diff"><code>SpinSystem:diff</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute the absolute difference between the current <a href="#SpinSystem">SpinSystem</a> and a given <a href="#SpinSystem">SpinSystem</a>. dx = Sum( |x[i] - other:x[i]|)</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>: to compare against.</dd>
<dt>Output</dt><dd>4 Numbers: The differences in the x, y and z components and the length of the difference vector.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:extraData"><code>SpinSystem:extraData</code></a></h3>
<dl>
<dt>Description</dt><dd>Get site specific extra data. This may be used for book keeping during initialization.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Site position. Implicit PBC.</dd>
<dt>Output</dt><dd>1 Value: The value stored at this site position.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:extraDataIterator"><code>SpinSystem:extraDataIterator</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience function to iterate over extraData in a <a href="#SpinSystem">SpinSystem</a>. Example:<br> <pre>
for pos, data in ss:extraDataIterator() do
	print(table.concat(pos, ","), data)
end
</pre> </dd>
<dt>Input</dt><dd>1 Optional Boolean: Include nil flag. By default nil entries will be included. If the optional boolean is false then the nil entries will be skipped.</dd>
<dt>Output</dt><dd>1 Iterator Function: Each function call returns a table of {i,j,k} and the data at that position.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:field"><code>SpinSystem:field</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the field at a site due to an interaction</dd>
<dt>Input</dt><dd>1 String, 1 <a href="#3Vector">3Vector</a>: The first argument identifies the field interaction type, one of: "Total", "Exchange", "Applied", "Anisotropy", "Thermal", "Dipole". The second argument selects the lattice site.</dd>
<dt>Output</dt><dd>4 Numbers: The field vector at the site and the magnitude fo the field</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:fieldArrayX"><code>SpinSystem:fieldArrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the X components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String: The name of the field</dd>
<dt>Output</dt><dd>1 Array: The X components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:fieldArrayY"><code>SpinSystem:fieldArrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the Y components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String: The name of the field</dd>
<dt>Output</dt><dd>1 Array: The Y components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:fieldArrayZ"><code>SpinSystem:fieldArrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the Z components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String: The name of the field</dd>
<dt>Output</dt><dd>1 Array: The Z components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:gamma"><code>SpinSystem:gamma</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the gamma value for the spin system. This is used in <a href="#LLG">LLG</a> routines.</dd>
<dt>Output</dt><dd>1 Number: The gamma value.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:invalidateFourierData"><code>SpinSystem:invalidateFourierData</code></a></h3>
<dl>
<dt>Description</dt><dd>Invalidates the cache of the Fourier transform of the spin system. If the time changes or :setSpin is called then the cache is invalidated but there are cases, such as when the internal arrays are exported and modified, when the SpinSystem isn't aware of changes. This function help to deal with those extreme cases</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:inverseSpin"><code>SpinSystem:inverseSpin</code></a></h3>
<dl>
<dt>Description</dt><dd>Return an element of the Fourier Transform of the lattice.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site</dd>
<dt>Output</dt><dd>6 numbers: The s(q) value represented as a triplet of tables. Each table represents the x, y or z component and the table values [1] and [2] are the real and imaginary parts</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:inverseSpinX"><code>SpinSystem:inverseSpinX</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a component of an element of the Fourier Transform of the lattice.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site</dd>
<dt>Output</dt><dd>1 table: The sx(q) value represented a tables with values [1] and [2] as the real and imaginary parts</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:inverseSpinY"><code>SpinSystem:inverseSpinY</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a component of an element of the Fourier Transform of the lattice.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site</dd>
<dt>Output</dt><dd>1 table: The sy(q) value represented a tables with values [1] and [2] as the real and imaginary parts</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:inverseSpinZ"><code>SpinSystem:inverseSpinZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Return a component of an element of the Fourier Transform of the lattice.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site</dd>
<dt>Output</dt><dd>1 table: The sz(q) value represented a tables with values [1] and [2] as the real and imaginary parts</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:moveToward"><code>SpinSystem:moveToward</code></a></h3>
<dl>
<dt>Description</dt><dd>Make the calling <a href="#SpinSystem">SpinSystem</a> look like a blend between itself and the given <a href="#SpinSystem">SpinSystem</a> by a certain ratio. 0 = no change, 1 = completely like the given.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, 1 Number: The goal SpinSystem and the amount to change.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:netField"><code>SpinSystem:netField</code></a></h3>
<dl>
<dt>Description</dt><dd>Return average field due to an interaction. This field must be calculated with the appropriate operator.</dd>
<dt>Input</dt><dd>1 String: The name of the field type to return. One of: "Total", "Exchange", "Applied", "Anisotropy", "Thermal", "Dipole"</dd>
<dt>Output</dt><dd>3 numbers: Vector representing the average field due to an interaction type.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:netMoment"><code>SpinSystem:netMoment</code></a></h3>
<dl>
<dt>Description</dt><dd>Calculate and return net magnetization of a spin system</dd>
<dt>Input</dt><dd>Up to 3 Optional Array.Double, 1 Optional Number: The optional double arrays scale each site by the product of their values, the optional number scales all sites by a single number. A combination of arrays and a single value can be supplied.</dd>
<dt>Output</dt><dd>8 numbers: mean(x), mean(y), mean(z), mean(M), mean(xx), mean(yy), mean(zz), mean(MM)</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:nx"><code>SpinSystem:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the first dimensions of the lattice.</dd>
<dt>Output</dt><dd>1 Integer: Size of the first dimension.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:ny"><code>SpinSystem:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the second dimensions of the lattice.</dd>
<dt>Output</dt><dd>1 Integer: Size of the second dimension.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:nz"><code>SpinSystem:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the third dimensions of the lattice.</dd>
<dt>Output</dt><dd>1 Integer: Size of the third dimension.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:resetFields"><code>SpinSystem:resetFields</code></a></h3>
<dl>
<dt>Description</dt><dd>Zero all the fields.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:rotateToward"><code>SpinSystem:rotateToward</code></a></h3>
<dl>
<dt>Description</dt><dd>Make the calling <a href="#SpinSystem">SpinSystem</a> look like a blend between itself and the given <a href="#SpinSystem">SpinSystem</a> by rotating the calling system toward the goal system.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, 1 Number or 1 Array: The goal SpinSystem and the maximum rotation angle (global value for the Number, site by site maximum for the array).</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setAlpha"><code>SpinSystem:setAlpha</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the damping value for the spin system. This is used in <a href="#LLG">LLG</a> routines as well as <a href="#Thermal">Thermal</a> calculations.</dd>
<dt>Input</dt><dd>1 Number: The damping value (default 1).</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setExtraData"><code>SpinSystem:setExtraData</code></a></h3>
<dl>
<dt>Description</dt><dd>Set site specific extra data. This may be used for book keeping during initialization.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>, 1 Value: Stores the value at the site specified. Implicit PBC.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setFieldArrayX"><code>SpinSystem:setFieldArrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the X components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String, 1 Array: The name of the field, the new X components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setFieldArrayY"><code>SpinSystem:setFieldArrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the Y components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String, 1 Array: The name of the field, the new Y components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setFieldArrayZ"><code>SpinSystem:setFieldArrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the Z components of the field vectors for a given type</dd>
<dt>Input</dt><dd>1 String, 1 Array: The name of the field, the new Z components of the field for each sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setGamma"><code>SpinSystem:setGamma</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the gamma value for the spin system. This is used in <a href="#LLG">LLG</a> routines.</dd>
<dt>Input</dt><dd>1 Number: The gamma value.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSiteAlpha"><code>SpinSystem:setSiteAlpha</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an individual site's damping to a unique value</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>, 1 Number: Site and value</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSiteAlphaArray"><code>SpinSystem:setSiteAlphaArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the internal site by site damping array to a new array</dd>
<dt>Input</dt><dd>1 Array: New damping array</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSiteGamma"><code>SpinSystem:setSiteGamma</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an individual site's gyromagnetic value to a unique value</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>, 1 Number: Site and value</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSiteGammaArray"><code>SpinSystem:setSiteGammaArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the internal site by site gyromagnetic array to a new array</dd>
<dt>Input</dt><dd>1 Array: New gyromagnetic array</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSlotUsed"><code>SpinSystem:setSlotUsed</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an internal variable. If true this field type will be added in the sum fields method.</dd>
<dt>Input</dt><dd>1 String, 0 or 1 Boolean: A field name and a flag to include or exclude the field in the summation method. Default value is true</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpin"><code>SpinSystem:setSpin</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the orientation and magnitude of a spin at a site.</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s, 1 optional number: The first argument represents a lattice site. The second represents the spin vector. If the third argument is a number, the spin vector will be scaled to this length.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpinArrayM"><code>SpinSystem:setSpinArrayM</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the entire array representing the magnitude of the sites to the given array.</dd>
<dt>Input</dt><dd>1 Array: The new magnitude of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpinArrayX"><code>SpinSystem:setSpinArrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the entire array representing the X components of the sites to the given array.</dd>
<dt>Input</dt><dd>1 Array: The new X components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpinArrayY"><code>SpinSystem:setSpinArrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the entire array representing the Y components of the sites to the given array.</dd>
<dt>Input</dt><dd>1 Array: The new Y components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpinArrayZ"><code>SpinSystem:setSpinArrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the entire array representing the Z components of the sites to the given array.</dd>
<dt>Input</dt><dd>1 Array: The new Z components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setSpinTPR"><code>SpinSystem:setSpinTPR</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the orientation and magnitude of a spin at a site using spherical coodinates. Note, the theta and phi follow math conventions, not physics conventions. Theta is the azimuthal angle renging from 0 to 2pi, Phi is the zenith angle ranging from 0 to pi.</dd>
<dt>Input</dt><dd>2 <a href="#3Vector">3Vector</a>s: The first argument represents a lattice site. The second represents the spin vector in spherical coordinates.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setTime"><code>SpinSystem:setTime</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the time of the simulation.</dd>
<dt>Input</dt><dd>1 Number: New time for the simulation (default: 0).</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:setTimeStep"><code>SpinSystem:setTimeStep</code></a></h3>
<dl>
<dt>Description</dt><dd>Set the time step for the spin system. This is used in <a href="#LLG">LLG</a> routines as well as <a href="#Thermal">Thermal</a> calculations.</dd>
<dt>Input</dt><dd>1 Number: The time step.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:siteAlpha"><code>SpinSystem:siteAlpha</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an individual site's damping value</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Site</dd>
<dt>Output</dt><dd>1 Number: Value</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:siteAlphaArray"><code>SpinSystem:siteAlphaArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the internal site by site damping array</dd>
<dt>Output</dt><dd>1 Array: Internal damping array</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:siteGamma"><code>SpinSystem:siteGamma</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an individual site's gyromagnetic value</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: Site</dd>
<dt>Output</dt><dd>1 Number: Value</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:siteGammaArray"><code>SpinSystem:siteGammaArray</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the internal site by site gyromagnetic array</dd>
<dt>Output</dt><dd>1 Array: Internal gyromagnetic array</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:siteIterator"><code>SpinSystem:siteIterator</code></a></h3>
<dl>
<dt>Description</dt><dd>Convenience function to iterate over sites in a <a href="#SpinSystem">SpinSystem</a>. Example:<br> <pre>
for position, moment in ss:siteIterator() do
	ss:setSpin(position, {1,0,0})
end
</pre> </dd>
<dt>Input</dt><dd>1 Optional Boolean: Include vacancy flag. By default vacant sites will be included. If the optional boolean is false then the vacant sites will be skipped.</dd>
<dt>Output</dt><dd>1 Iterator Function: Each function call returns a table of position as {i,j,k} and the moment direction and magnitude as a table {x,y,z,m}.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:slotUsed"><code>SpinSystem:slotUsed</code></a></h3>
<dl>
<dt>Description</dt><dd>Deternime if an internal field slot has been set</dd>
<dt>Input</dt><dd>1 String: A field name</dd>
<dt>Output</dt><dd>1 Boolean: The return value</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spin"><code>SpinSystem:spin</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the orientation and magnitude of a spin at a site.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site.</dd>
<dt>Output</dt><dd>4 Numbers: The spin vector at the lattice site and magnitude.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spinArrayM"><code>SpinSystem:spinArrayM</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the magnitude of all sites. This array is connected to the SpinSystem so changes to the returned array will change the SpinSystem.</dd>
<dt>Output</dt><dd>1 Array: The magnitude of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spinArrayX"><code>SpinSystem:spinArrayX</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the X components of all sites. This array is connected to the SpinSystem so changes to the returned array will change the SpinSystem.</dd>
<dt>Output</dt><dd>1 Array: The X components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spinArrayY"><code>SpinSystem:spinArrayY</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Y components of all sites. This array is connected to the SpinSystem so changes to the returned array will change the SpinSystem.</dd>
<dt>Output</dt><dd>1 Array: The Y components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spinArrayZ"><code>SpinSystem:spinArrayZ</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the Z components of all sites. This array is connected to the SpinSystem so changes to the returned array will change the SpinSystem.</dd>
<dt>Output</dt><dd>1 Array: The Z components of the sites.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:spinTPR"><code>SpinSystem:spinTPR</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the orientation and magnitude of a spin at a site using spherical coodinates. Note, the theta and phi follow math conventions, not physics conventions. Theta is the azimuthal angle renging from 0 to 2pi, Phi is the zenith angle ranging from 0 to pi.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site.</dd>
<dt>Output</dt><dd>3 Numbers: The azimutal, zenith and radial components.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:sumFields"><code>SpinSystem:sumFields</code></a></h3>
<dl>
<dt>Description</dt><dd>Sum all the fields into a single effective field.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:time"><code>SpinSystem:time</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the time of the simulation.</dd>
<dt>Output</dt><dd>1 Number: Time of the simulation.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:timeStep"><code>SpinSystem:timeStep</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the time step for the spin system. This is used in <a href="#LLG">LLG</a> routines as well as <a href="#Thermal">Thermal</a> calculations.</dd>
<dt>Output</dt><dd>1 Number: The time step.</dd>
</dl><hr>
<p>
<h3><a name="SpinSystem:unitSpin"><code>SpinSystem:unitSpin</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the orientation of a spin at a site.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>: The lattice site.</dd>
<dt>Output</dt><dd>1 <a href="#3Vector">3Vector</a>: The spin normalized vector at the lattice site.</dd>
</dl><hr>
<p>
<h2><a name="Thermal">Thermal</a></h2>
<p>
Generates a the random thermal field of a <a href="#SpinSystem">SpinSystem</a>
<p><dl><dt>Thermal.new() takes the following arguments</dt><dd>1 <a href="#3Vector">3Vector</a> or <a href="#SpinSystem">SpinSystem</a>, 1 Optional <a href="#Random">Random</a>: System Size and built in RNG</dd></dl>
<hr>
<p>
<h3><a name="Thermal:apply"><code>Thermal:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Generates a the random thermal field of a <a href="#SpinSystem">SpinSystem</a></dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, 1 Optional <a href="#Random">Random</a>,: The first argument is the spin system which will receive the field. The second optional argument is a random number generator that is used as a source of random values, if absent then the RNG supplied in the constructor will be used.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:arrayScale"><code>Thermal:arrayScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get an array representing the thermal scale at each site. This array is connected to the Operator so changes to the returned array will change the Operator.</dd>
<dt>Output</dt><dd>1 Array: The thermal scale of the sites.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:get"><code>Thermal:get</code></a></h3>
<dl>
<dt>Description</dt><dd>Gets the base value of the temperature. </dd>
<dt>Output</dt><dd>1 number: temperature of the system.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:member"><code>Thermal:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Thermal:nx"><code>Thermal:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Thermal:ny"><code>Thermal:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Thermal:nz"><code>Thermal:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Thermal:random"><code>Thermal:random</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the <a href="#Random">Random</a> number generator supplied at initialization</dd>
<dt>Output</dt><dd>1 <a href="#Random">Random</a> or 1 nil: RNG</dd>
</dl><hr>
<p>
<h3><a name="Thermal:scale"><code>Thermal:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Thermal:scaleSite"><code>Thermal:scaleSite</code></a></h3>
<dl>
<dt>Description</dt><dd>Scale the thermal field at a site. This allows non-uniform thermal effects over a lattice.</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a>, 1 Number: The vectors define the lattice sites that will have a scaled thermal effect, the number is the how the thermal field is scaled.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:set"><code>Thermal:set</code></a></h3>
<dl>
<dt>Description</dt><dd>Sets the base value of the temperature. </dd>
<dt>Input</dt><dd>1 number: temperature of the system.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:setArrayScale"><code>Thermal:setArrayScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set an array representing the new thermal scale at each site.</dd>
<dt>Input</dt><dd>1 Array: The thermal scale of the sites.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:setScale"><code>Thermal:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h3><a name="Thermal:setTemperature"><code>Thermal:setTemperature</code></a></h3>
<dl>
<dt>Description</dt><dd>Sets the base value of the temperature. </dd>
<dt>Input</dt><dd>1 number: temperature of the system.</dd>
</dl><hr>
<p>
<h3><a name="Thermal:temperature"><code>Thermal:temperature</code></a></h3>
<dl>
<dt>Description</dt><dd>Gets the base value of the temperature. </dd>
<dt>Output</dt><dd>1 number: temperature of the system.</dd>
</dl><hr>
<p>
<h2><a name="Timer">Timer</a></h2>
<p>
Create a timer to profile code
<p><dl><dt>Timer.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Timer:elapsed"><code>Timer:elapsed</code></a></h3>
<dl>
<dt>Description</dt><dd>Get elapsed seconds since last reset/start</dd>
<dt>Output</dt><dd>1 number: elapsed seconds</dd>
</dl><hr>
<p>
<h3><a name="Timer:nanoseconds"><code>Timer:nanoseconds</code></a></h3>
<dl>
<dt>Description</dt><dd>Get elapsed nanoseconds since last reset/start</dd>
<dt>Output</dt><dd>1 number: elapsed nanoseconds</dd>
</dl><hr>
<p>
<h3><a name="Timer:pause"><code>Timer:pause</code></a></h3>
<dl>
<dt>Description</dt><dd>Pause timer</dd>
</dl><hr>
<p>
<h3><a name="Timer:seconds"><code>Timer:seconds</code></a></h3>
<dl>
<dt>Description</dt><dd>Get elapsed seconds since last reset/start</dd>
<dt>Output</dt><dd>1 number: elapsed seconds</dd>
</dl><hr>
<p>
<h3><a name="Timer:start"><code>Timer:start</code></a></h3>
<dl>
<dt>Description</dt><dd>Reset and start timer.</dd>
</dl><hr>
<p>
<h3><a name="Timer:stop"><code>Timer:stop</code></a></h3>
<dl>
<dt>Description</dt><dd>Stop timer.</dd>
</dl><hr>
<p>
<h2><a name="Wood">Wood</a></h2>
<p>
Wood updates a <a href="#SpinSystem">SpinSystem</a> using a form of the Woods equation.
<p><dl><dt>Wood.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="Wood.effectiveAnisotropy">Wood.effectiveAnisotropy</a></h3>
<dl>
<dt>Description</dt><dd>No documentation. Check the source code.</dd>
</dl><hr>
<p>
<h3><a name="Wood:adjustMagnetostatics"><code>Wood:adjustMagnetostatics</code></a></h3>
<dl>
<dt>Description</dt><dd>Set local demag factors and remove the self term from the magnetostatic tensor.</dd>
<dt>Input</dt><dd>1 <a href="#Magnetostatics2D">Magnetostatics2D</a>: Magnetostatics object to modify.</dd>
</dl><hr>
<p>
<h3><a name="Wood:apply"><code>Wood:apply</code></a></h3>
<dl>
<dt>Description</dt><dd>Compute 1 Wood Step.</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, 1 <a href="#Anisotropy">Anisotropy</a>, 1 <a href="#Magnetostatics2D">Magnetostatics2D</a>, 1 optional <a href="#SpinSystem">SpinSystem</a>, 1 String: Calculate 1 Wood iteration from the 1st SpinSystem using the calculated effective fields and the given Anisotropy operator writing the new state either into the 2nd SpinSystem (if provided) or back into the 1st SpinSystem. The string defines the method and should be one of `Min_close', `Min_far' or `Max'.The last number or table of numbers is the cell sizes/volumes for each layer.</dd>
<dt>Output</dt><dd>1 Integer: Number of sites that were updated</dd>
</dl><hr>
<p>
<h3><a name="Wood:calculateEnergyBarriers"><code>Wood:calculateEnergyBarriers</code></a></h3>
<dl>
<dt>Description</dt><dd>Calculate the energy barriers at each site</dd>
<dt>Input</dt><dd>1 <a href="#SpinSystem">SpinSystem</a>, 1 <a href="#Anisotropy">Anisotropy</a>, 1 <a href="#Magnetostatics2D">Magnetostatics2D</a>: Using the spin configuration, fields, anisotropies and geometry calculate the energy barrier to flip at each site. </dd>
</dl><hr>
<p>
<h3><a name="Wood:energyBarrier"><code>Wood:energyBarrier</code></a></h3>
<dl>
<dt>Description</dt><dd>Return the calculated energy barrier at a site</dd>
<dt>Input</dt><dd>3 Integers: The x, y and z coordinate (base 1) of the target site.</dd>
<dt>Output</dt><dd>1 Number: Energy barrier at (x,y,z)</dd>
</dl><hr>
<p>
<h3><a name="Wood:getDemag"><code>Wood:getDemag</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the demag value at the given layer.</dd>
<dt>Input</dt><dd>1 Integer: Layer number (base 1).</dd>
<dt>Output</dt><dd>1 Number: Demag factor for the layer.</dd>
</dl><hr>
<p>
<h3><a name="Wood:member"><code>Wood:member</code></a></h3>
<dl>
<dt>Description</dt><dd>Test if the given site index is part of the operator</dd>
<dt>Input</dt><dd>1 <a href="#3Vector">3Vector</a> (Integers): Index of site to test</dd>
<dt>Output</dt><dd>1 Boolean: Result of test</dd>
</dl><hr>
<p>
<h3><a name="Wood:nx"><code>Wood:nx</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the x direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Wood:ny"><code>Wood:ny</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the y direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Wood:nz"><code>Wood:nz</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the size in the z direction that this operator was created with.</dd>
<dt>Output</dt><dd>1 Number: size</dd>
</dl><hr>
<p>
<h3><a name="Wood:scale"><code>Wood:scale</code></a></h3>
<dl>
<dt>Description</dt><dd>Get the scale applied to field calculatons (default value is 1.0)</dd>
<dt>Output</dt><dd>1 Number: The scale</dd>
</dl><hr>
<p>
<h3><a name="Wood:setScale"><code>Wood:setScale</code></a></h3>
<dl>
<dt>Description</dt><dd>Set a scale to field calculatons (default value is 1.0)</dd>
<dt>Input</dt><dd>1 Number: The value of the new scale</dd>
</dl><hr>
<p>
<h2><a name="_G">_G</a></h2>
<p>
This is the Global Scope for MagLua. The following are custom functions added to the base language to help create and run simulations.
<hr>
<p>
<h3><a name="checkpointFromString">checkpointFromString</a></h3>
<dl>
<dt>Description</dt><dd>Function to load zero or more values from a checkpoint string encoded using the uuencode algorithm. Encoded data use only printable characters and so can be easily emailed, copied to a clipboard, stored in a text file or stored in a database.<br>Example: <pre>
s = [[begin 600 checkpoint.dat
M0TA%0TM03TE.5```````````````````````````````````````````````
M````````````````````````````````````````````````````````````
M```````````````````````````````````````````````````#````&lt;P``
M``8```!K````&TQU85$``00(!`@`"0````````!`86%A+FQU80`!`````P``
M```!``(#````3@```%X```$&gt;`(`````````````#`````@````(````#````
M`0````(`````````&gt;````````@`````````,`````P```````````!1`-```
M``4````"`````P```````````/`_!`````(```!A``,`````````````0`0`
(```"````8@``
`
end]]
	
f, v, t = checkpointFromString(s)

</pre> <br></dd>
<dt>Input</dt><dd>1 String: The string representing the values as a printable string encoded using the uuencode algorithm.</dd>
<dt>Output</dt><dd>0 or more Values: Values will be decoded and returned.</dd>
</dl><hr>
<p>
<h3><a name="checkpointLoad">checkpointLoad</a></h3>
<dl>
<dt>Description</dt><dd>Function to load zero or more values from a checkpoint file. <br>Example:<br> <pre>
g, value, t = checkpointLoad("checkpoint_help_example.dat")
print(g(value), t[1], t2])
</pre> <br></dd>
<dt>Input</dt><dd>1 String: The String is the file to be read</dd>
<dt>Output</dt><dd>0 or more Values: The values encoded in the file are returned from the function.</dd>
</dl><hr>
<p>
<h3><a name="checkpointSave">checkpointSave</a></h3>
<dl>
<dt>Description</dt><dd>Function to save zero or more values to a checkpoint file. <br>Example:<br> <pre>
function f(x)
	return x*x
end

checkpointSave("checkpoint_help_example.dat", f, 5, {"a", "b"})
</pre> </dd>
<dt>Input</dt><dd>1 String, 0 or more Values: The String is the file name to be used, values will be encoded and saved to file</dd>
</dl><hr>
<p>
<h3><a name="checkpointToString">checkpointToString</a></h3>
<dl>
<dt>Description</dt><dd>Function to save zero or more values to a checkpoint string encoded using the uuencode algorithm. Encoded data use only printable characters and so can be easily emailed, copied to a clipboard, stored in a text file or stored in a database.<br>Example: <pre>
function f(x)
	return x*x
end

s = checkpointToString(f, 5, {"a", "b"})
print(s)
</pre> <br>Expected Output:<br> <pre>
begin 600 checkpoint.dat
M0TA%0TM03TE.5```````````````````````````````````````````````
M````````````````````````````````````````````````````````````
M```````````````````````````````````````````````````#````&lt;P``
M``8```!K````&TQU85$``00(!`@`"0````````!`86%A+FQU80`!`````P``
M```!``(#````3@```%X```$&gt;`(`````````````#`````@````(````#````
M`0````(`````````&gt;````````@`````````,`````P```````````!1`-```
M``4````"`````P```````````/`_!`````(```!A``,`````````````0`0`
(```"````8@``
`
end
</pre> <br></dd>
<dt>Input</dt><dd>0 or more Values: Values will be encoded and returned as a string</dd>
<dt>Output</dt><dd>1 String: The string representing the values as a printable string encoded using the uuencode algorithm.</dd>
</dl><hr>
<p>
<h2><a name="math">math</a></h2>
<p>
This is the custom Math Scope for MagLua. The following are custom functions added to the base language to help create and run simulations.
<hr>
<p>
<h3><a name="math.angleBetween">math.angleBetween</a></h3>
<dl>
<dt>Description</dt><dd>Compute the angle between 2 vectors</dd>
<dt>Input</dt><dd>2 Tables of Numbers: Input</dd>
<dt>Output</dt><dd>1 Number: Angle</dd>
</dl><hr>
<p>
<h3><a name="math.cross">math.cross</a></h3>
<dl>
<dt>Description</dt><dd>Compute the cross product between 2 3-Vectors</dd>
<dt>Input</dt><dd>2 Tables of 3 Numbers: Input</dd>
<dt>Output</dt><dd>1 Table of 3 Numbers: Product</dd>
</dl><hr>
<p>
<h3><a name="math.dot">math.dot</a></h3>
<dl>
<dt>Description</dt><dd>Compute the dot product between 2 Vectors</dd>
<dt>Input</dt><dd>2 Tables of Numbers: Input</dd>
<dt>Output</dt><dd>1 Number: Product</dd>
</dl><hr>
<p>
<h3><a name="math.norm">math.norm</a></h3>
<dl>
<dt>Description</dt><dd>Compute the length of a vector</dd>
<dt>Input</dt><dd>1 Table of Numbers: Input</dd>
<dt>Output</dt><dd>1 Number: Length</dd>
</dl><hr>
<p>
<h3><a name="math.project">math.project</a></h3>
<dl>
<dt>Description</dt><dd>Compute the projection of one vector onto another</dd>
<dt>Input</dt><dd>2 Tables of Numbers: Input</dd>
<dt>Output</dt><dd>1 Table of Numbers: Projection</dd>
</dl><hr>
<p>
<h3><a name="math.rotateAboutBy">math.rotateAboutBy</a></h3>
<dl>
<dt>Description</dt><dd>Rotate a vector about another by a given numer of radians</dd>
<dt>Input</dt><dd>2 Tables of 3 Numbers, 1 Number: Source Vector, Rotation axis, radians to rotate</dd>
<dt>Output</dt><dd>1 Table of 3 Numbers: Rotated Vector</dd>
</dl><hr>
<p>
<h3><a name="math.scaledVector">math.scaledVector</a></h3>
<dl>
<dt>Description</dt><dd>Scale all elements in the given table by the numeric amount</dd>
<dt>Input</dt><dd>1 Table, 1 Number: Source Vector, Scale amount</dd>
<dt>Output</dt><dd>1 Table: Scaled Vector</dd>
</dl><hr>
<p>
<h2><a name="mpi">mpi</a></h2>
<p>
Exposes basic and new convenience MPI functions
<p><dl><dt>mpi.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="mpi.barrier">mpi.barrier</a></h3>
<dl>
<dt>Description</dt><dd>Syncronization barrier</dd>
</dl><hr>
<p>
<h3><a name="mpi.bcast">mpi.bcast</a></h3>
<dl>
<dt>Description</dt><dd>Broadcast data to all members of the workgrroup from the given rank.</dd>
<dt>Input</dt><dd>1 Integer, 1 value: The value is what will be broadcasted, the integer is the rank where the data will be from.</dd>
<dt>Output</dt><dd>1 value. The broadcasted data.</dd>
</dl><hr>
<p>
<h3><a name="mpi.cart_coord">mpi.cart_coord</a></h3>
<dl>
<dt>Description</dt><dd>Lookup coordinate in cartesian workgroup based on rank.</dd>
<dt>Input</dt><dd>1 Integer: Rank of workgroup member.</dd>
<dt>Output</dt><dd>1 Table of integers: Coordinate at given rank.</dd>
</dl><hr>
<p>
<h3><a name="mpi.cart_create">mpi.cart_create</a></h3>
<dl>
<dt>Description</dt><dd>Create a cartesian workgroup, maximum 10 dimensions. 3D Example with periodic bounds in the 1st and 2nd dimension:<br> <pre>mpi_cart = mpi.cart_create({3,3,2}, {true,true,false})
</pre> </dd>
<dt>Input</dt><dd>2 Tables, 1 Optional Boolean: The first table contains sizes of each dimension, the second is a table of booleans indicating if each dimension should be periodic. The last boolean argument states if the ranks may be reordered (default true, some MPI implementations ignore this value)</dd>
<dt>Output</dt><dd>1 MPI_Comm: Optimized for cartesian communication. In the case that the number of processes in the calling workgroup is larger than the number of processes in the new workgroup, nils will be returned to some members.</dd>
</dl><hr>
<p>
<h3><a name="mpi.cart_rank">mpi.cart_rank</a></h3>
<dl>
<dt>Description</dt><dd>Lookup rank in a cartesian workgroup based on coordinate.</dd>
<dt>Input</dt><dd>1 Table of integers: Coordinate to lookup, values will be wrapped for periodic dimensions.</dd>
<dt>Output</dt><dd>1 Integer: Rank of workgroup member at given coodinate.</dd>
</dl><hr>
<p>
<h3><a name="mpi.comm_split">mpi.comm_split</a></h3>
<dl>
<dt>Description</dt><dd>Split a workgroup into sub groups by common colours (integers).<br>Example with mpirun -n 8:<br> <pre>rank = mpi.get_rank()
size = mpi.get_size()

new_group = {1,1,1,2,2,1,5,2}

split_comm = mpi.comm_split(new_group[rank])
split_rank = split_comm:get_rank()
split_size = split_comm:get_size()

for i=1,size do
	if rank == i then
		print(rank .. "/" .. size .. " -> " .. split_rank .. "/" .. split_size)
	end
	mpi.barrier()
end
</pre> Output<br> <pre>1/8 -> 1/4
2/8 -> 2/4
3/8 -> 3/4
4/8 -> 1/3
5/8 -> 2/3
6/8 -> 4/4
7/8 -> 1/1
8/8 -> 3/3
</pre> </dd>
<dt>Input</dt><dd>1 Integer: The colour for the MPI_Comm_split function. Processes with common colours will be put into common sub-workgroups.</dd>
<dt>Output</dt><dd>1 MPI_Comm: Sub-Workgroup</dd>
</dl><hr>
<p>
<h3><a name="mpi.gather">mpi.gather</a></h3>
<dl>
<dt>Description</dt><dd>Gather data to a given rank. The return at the rank will be a table with each data as the value for source keys.</dd>
<dt>Input</dt><dd>1 Integer, 1 value: The value is what will be gathered, the Integer is the rank where the data will be gathered.</dd>
<dt>Output</dt><dd>1 table or nil. The table will be returned at the given rank otherwise nil.</dd>
</dl><hr>
<p>
<h3><a name="mpi.get_processor_name">mpi.get_processor_name</a></h3>
<dl>
<dt>Description</dt><dd>Returns the name of the processor as known by MPI.</dd>
<dt>Output</dt><dd>1 String: Name</dd>
</dl><hr>
<p>
<h3><a name="mpi.get_rank">mpi.get_rank</a></h3>
<dl>
<dt>Description</dt><dd>The rank of the calling process as a base 1 value. Note: The C and Fortran bindings for MPI use base 0 for ranks, this is automatically translated to base 1 in MagLua for esthetics and language consistency.</dd>
<dt>Output</dt><dd>1 Number: Rank</dd>
</dl><hr>
<p>
<h3><a name="mpi.get_size">mpi.get_size</a></h3>
<dl>
<dt>Description</dt><dd>Return the total number of proccesses in the global workgroup</dd>
<dt>Output</dt><dd>1 Number: Number of processes</dd>
</dl><hr>
<p>
<h3><a name="mpi.irecv">mpi.irecv</a></h3>
<dl>
<dt>Description</dt><dd>Asynchronously receive data from another process in the workgroups.</dd>
<dt>Input</dt><dd>2 Integers: Rank of remote process, tag to be matched on the sending side.</dd>
<dt>Output</dt><dd>1 <a href="#mpi.request">mpi.request</a>: This request is used to check to see if the communication is complete. The data may be retrieved from this object.</dd>
</dl><hr>
<p>
<h3><a name="mpi.isend">mpi.isend</a></h3>
<dl>
<dt>Description</dt><dd>Asynchronously send data to another process in the workgroups. Example:<br> <pre>-- tags ensure that different asynchronous communications don't clash
local tag = 5

if mpi.get_rank() == 2 then
    recv_request = mpi.irecv(1, tag)
end

mpi.barrier() -- barrier to show that an irecv can be before an isend

if mpi.get_rank() == 1 then
    send_request = mpi.isend(2, tag, "hello", 5,6,7)
end

if mpi.get_rank() == 2 then
    print(recv_request:data()) -- not guaranteed to print data
    recv_request:wait()
    print(recv_request:data()) -- guaranteed to print "hello   5       6       7"
end
</pre> </dd>
<dt>Input</dt><dd>2 Integers, ...: Rank of remote process, tag to be matched on the receiving side followed  by zero or more data</dd>
<dt>Output</dt><dd>1 <a href="#mpi.request">mpi.request</a>: This request is used to check to see if the communication is complete.</dd>
</dl><hr>
<p>
<h3><a name="mpi.range">mpi.range</a></h3>
<dl>
<dt>Description</dt><dd>Make an iterator that iterates over different balanced sequential chunks of a range for each MPI process. Example use:<br> <pre>for i in mpi.range(1,10) do
	print(mpi.get_rank(), i)
end
</pre> </dd>
<dt>Input</dt><dd>2 Numbers, 1 Optional Number: The first two numbers represent the start and end points (inclusive) of the range. The optional third number gives a step size (default 1).</dd>
<dt>Output</dt><dd>1 Function: The function will return sequential values in the local chunk for each function call. The function will return nil when the range has been exhausted.</dd>
</dl><hr>
<p>
<h3><a name="mpi.recv">mpi.recv</a></h3>
<dl>
<dt>Description</dt><dd>Receive data from another process in the workgroup</dd>
<dt>Input</dt><dd>1 Number: Index of remote process sending the data</dd>
<dt>Output</dt><dd>...: zero or more pieces of data</dd>
</dl><hr>
<p>
<h3><a name="mpi.send">mpi.send</a></h3>
<dl>
<dt>Description</dt><dd>Send data to another process in the workgroup. Example:<br> <pre>if mpi.get_rank() == 1 then
	-- sending an anonymous function and some data
	local msg = "hello"
	mpi.send(2, function(x) print(x,x) end, msg)
end
if mpi.get_rank() == 2 then
	f, x = mpi.recv(1)
	f(x)
end
</pre> Output at process 2:<br> <pre>hello	hello</pre> </dd>
<dt>Input</dt><dd>1 Number, ...: Index of remote process followed by zero or more data</dd>
</dl><hr>
<p>
<h2><a name="mpi.request">mpi.request</a></h2>
<p>
A request object represents a pending asynchronous communication event
<p><dl><dt>mpi.request.new() takes the following arguments</dt><dd></dd></dl>
<hr>
<p>
<h3><a name="mpi.request:cancel"><code>mpi.request:cancel</code></a></h3>
<dl>
<dt>Description</dt><dd>Cancel pending communication</dd>
</dl><hr>
<p>
<h3><a name="mpi.request:data"><code>mpi.request:data</code></a></h3>
<dl>
<dt>Description</dt><dd>Retrieve the data if available</dd>
<dt>Output</dt><dd>...: Sent data if the communication is complete, nil otherwise. This will return a copy of the sent data on the sending side.</dd>
</dl><hr>
<p>
<h3><a name="mpi.request:test"><code>mpi.request:test</code></a></h3>
<dl>
<dt>Description</dt><dd>Test to see if a pending communication is complete, this will not block.</dd>
<dt>Output</dt><dd>1 boolean: true if complete, false otherwise.</dd>
</dl><hr>
<p>
<h3><a name="mpi.request:wait"><code>mpi.request:wait</code></a></h3>
<dl>
<dt>Description</dt><dd>Wait for pending communication to complete. This will block.</dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://RungeKutta.lua)">dofile("maglua://RungeKutta.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This support script implements the following integration types<br> <br>  <pre>RK1, RK2, RK3, RK4, RK4_38, RK6, K3, BS3</pre> <br><br> The integration types are available via the "make_rk_step_function(ss, type, fieldFunc, optional_dynamicsFunc, llg, optional_temp)" function which takes a <a href="#SpinSystem">SpinSystem</a>, a type which is a string equal to one of the listed types above, a field function that takes a <a href="#SpinSystem">SpinSystem</a> and computes the deterministic effective field, an LLG operator and an optional thermal operator. <br> Example:<br>  <pre>
 dofile("maglua://RungeKutta.lua")
 
 ss   = SpinSystem.new(40,40)
 ex   = Exchange.new(ss)
 dip  = Dipole.new(ss)
 ani  = Anisotropy.new(ss)
 temp = Thermal.new(ss, Random.Isaac.new())
 llg  = LLG.Quaternion.new()

 --1D interpolation object used as {time, temperature}
 temperature = Interpolate.new({{0,20}, {20,2}, {198,0}, {1e8,0}})

 max_time = 200
 ss:setTimeStep(5e-2)
 ex_str = 1/2
 ani_str = 5/2

 for i=1,ss:nx() do
 	for j=1,ss:ny() do
 		ss:setSpin({i,j}, {1,0,0})
 
 		ex:add({i,j}, {i+1,j}, ex_str)
 		ex:add({i,j}, {i-1,j}, ex_str)
 		ex:add({i,j}, {i,j+1}, ex_str)
 		ex:add({i,j}, {i,j-1}, ex_str)
 
 		ani:add({i,j}, {0,0,1}, ani_str)
 	end
 end
 
 function calcField(ss)
 	ss:resetFields()
 	ex:apply(ss)
 	dip:apply(ss)
 	ani:apply(ss)
 	ss:sumFields()
 end
 
 step = make_rk_step_function(ss, "RK4", calcField, llg, temp)
 
 while ss:time() < max_time do
 	temp:set(temperature:value(ss:time()))
 	step()
 end
 </pre> </dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://POVRay.lua)">dofile("maglua://POVRay.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This file provides a function that converts a <a href="#SpinSystem">SpinSystem</a> into a file that is ready to be rendered with the POV-Ray raytracer. The function is POVRay(filename, ss, custom) where filename is the output filename that will be written to, ss is the <a href="#SpinSystem">SpinSystem</a> and custom is an optional table interpreted as a JSON style table. The accepted keys-values in the custom table are:<br>  <pre>
 camera_position = {camx, camy, camz}
 camera_focus = {cam_atx, cam_aty, cam_atz}
 lights = {{light1x, light1y, light1z}, {light2x, light2y, light2z}, {light3...}, ...}},  
 color_function = function(sx,sy,sz) return r,g,b end
 position_function = function(x,y,z) return x,y,z end
 scale = 1.0
 </pre> <br> <br> Note: scale can be a number, an array or a function that takes site positions as input and returns the scale<br> <br> Example Usage:<br> <pre><br> dofile("maglua://POVRay.lua")<br><br> ss = SpinSystem.new(32,32)<br> ex = Exchange.new(ss)<br> llg = LLG.Cartesian.new(ss)<br> ss:setTimeStep(1e-3) <br><br> function r()<br>     return math.random()*2 - 1<br> end<br><br> for i=1,32 do<br>     for j=1,32 do<br>         ss:setSpin({i,j}, {r(), r(), r()}, 1)<br><br>         ex:add({i,j}, {i+1,j}, 1)<br>         ex:add({i,j}, {i-1,j}, 1)<br>         ex:add({i,j}, {i,j+1}, 1)<br>         ex:add({i,j}, {i,j-1}, 1)<br>     end<br> end<br><br> function step()<br>     ss:resetFields()<br>     ex:apply(ss)<br>     ss:sumFields()<br>     llg:apply(ss)<br> end<br><br> while ss:time() < 3 do<br>     step()<br> end<br><br> POVRay("example.pov", ss, {<br>     camera_position = {16,15,40}, <br>     camera_focus = {16,16,0}, <br>     color_function = function(sx,sy,sz) <br>         local r = (sx+1)/2 <br>         return r,r,r<br>     end})</dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://ColorMap.lua)">dofile("maglua://ColorMap.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This file provides the function `ColorMap(x,y,z)' that converts a direction (x,y,z) into red, green, blue<br> <br> Example Usage:<br>  <pre>
 dofile("maglua://ColorMap.lua")

 r, g, b = ColorMap(1, 0, 0)
 </pre> </dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://Help.lua)">dofile("maglua://Help.lua")</a></h2>
<dl>
<dt>Description</dt><dd><br> This script uses the built in help features of maglua to build an html help file<br> If an argument is supplied, that will be the output filename<br><br> Also provides the default Global Scope help function<br> </dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://PredictorCorrector.lua)">dofile("maglua://PredictorCorrector.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This support script implements predictor-corrector integration.<br> The function returns a step function and has the form:<br>  <pre>function make_pc_step_function(ss, calcField, llg, tol, optional_temp)</pre> <br> where ss is a <a href="#SpinSystem">SpinSystem</a>, calcField is a function that calculates the determinstic portion of the effective field, llg is a LLG operator and the optional parameter optional_temp is a temperature operator. <br><br> Example:<br>  <pre>
 dofile("maglua://PredictorCorrector.lua")
 
 ss   = SpinSystem.new(40,40)
 ex   = Exchange.new(ss)
 dip  = Dipole.new(ss)
 ani  = Anisotropy.new(ss)
 temp = Thermal.new(ss, Random.Isaac.new())
 llg  = LLG.Quaternion.new()

 --1D interpolation object used as {time, temperature}
 temperature = Interpolate.new({{0,20}, {20,2}, {198,0}, {1e8,0}})

 max_time = 200
 ss:setTimeStep(5e-2)
 ex_str = 1/2
 ani_str = 5/2

 for i=1,ss:nx() do
 	for j=1,ss:ny() do
 		ss:setSpin({i,j}, {1,0,0})
 
 		ex:add({i,j}, {i+1,j}, ex_str)
 		ex:add({i,j}, {i-1,j}, ex_str)
 		ex:add({i,j}, {i,j+1}, ex_str)
 		ex:add({i,j}, {i,j-1}, ex_str)
 
 		ani:add({i,j}, {0,0,1}, ani_str)
 	end
 end
 
 function calcField(ss)
 	ss:resetFields()
 	ex:apply(ss)
 	dip:apply(ss)
 	ani:apply(ss)
 	ss:sumFields()
 end
 
 step = make_pc_step_function(ss, calcField, llg, 0.001*40^2, temp)
 
 while ss:time() < max_time do
 	temp:set(temperature:value(ss:time()))
 	step()
 end
 </pre> </dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://AdaptiveTimeStep.lua)">dofile("maglua://AdaptiveTimeStep.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This script takes a step function and wraps it in an adaptive timestep scheme halfing or doubling the timestep as required to acheive a desired tolerance.<br> Function form:<br>  <pre>function make_adapt_step_function(ss, step, tolerance, dynamics, llg, optional_thermal_operator)</pre> <br> where ss is a <a href="#SpinSystem">SpinSystem</a>, step is a function that integrates over a timestep, tolerance is used to determine if two systems are the same, dynamics is an optional function (can be nil) that takes a <a href="#SpinSystem">SpinSystem</a> and modifies the environment, llg is an LLG operator (only required if a thermal operator is specified) and optional_thermal_operator is a thermal operator.</dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://MakeMacro.lua)">dofile("maglua://MakeMacro.lua")</a></h2>
<dl>
<dt>Description</dt><dd> This file provides a function `MakeMacro' that converts a <a href="#SpinSystem">SpinSystem</a> and operators into data and operators where sites may be combined into macro-sites. <br> The function arguments are flexible but the first must be a mapping table. The following are data and operators. One must be a SpinSystem, the others can be Exchange, Anisotropy, Applied and Thermal. <br> The return values will be a function that does a reverse mapping lookup and the transformed input in the order that they were supplied. <br> The mapping table is a list of macro sites where a macro site is a list of sites to be combined into a site. These sites can be in 1, 2 or 3 dimensional format. Consider the example below:<br><br>  <pre>
 mapping = { {{1}}, {{2}}, {{3}, {4}}, {5} }
 </pre> <br> This 1D mapping table will map the old site 1 onto the new site 1, the old site 2 onto the new site 2, the old sites 3 and 4 onto the new site 2 and the old site 5 onto the new site 4.<br> Old sites mapped to multiple new sites is unsupported. Invalid old sites are unsupported.<br><br> The first argument that is returned, the reverseMappingLookup function takes a single old site as a table and returns 3 integers. The first is the index of the new macro-site that contains the old site, the second is the index inside the new macro-site where the old site is contained and the last is the number of sites in the new macro-site.<br> <br> Example use:<br>  <pre>
 invmap, ssMacro, exMacro, aniMacro = MakeMacro(mapping, ss, ex, ani)
 </pre> <br> <br> If sites in the original system contain extraData then the first data in the mapping will be assigned to the extraData of the new system.</dd>
</dl><hr>
<p>
<h2><a name="dofile(maglua://CGS.lua)">dofile("maglua://CGS.lua")</a></h2>
<dl>
<dt>Description</dt><dd> maglua://CGS.lua provides the basic units for magnetism in the centimetre-gram-second system of units. The units and values provided are: cm, gram, s, Kelvin, erg, uerg, Gauss, emu, Oe, cc, nm, ps, ns, kB and gamma<br><br> Example usage: <br>  <pre>dofile("maglua://CGS.lua")
 
 Ms = 1414 * emu/cc
 cell = (8*nm) * (8*nm) * (16*nm)
 ss = SpinSystem.new(10,10)
 ss:setSpin({1,1}, {0,0,1}, Ms*cell)
 </pre> </dd>
</dl><hr>
<p>
<h2><a name="3Vector">3Vector</a></h2>
<dl>
<dt>Description</dt><dd>A 3Vector is an argument of some methods in MagLua, it can either be 3 numbers or a table with 3 values. If it is a table with less than 3 values, sensible defaults are used or an error is returned if none exist.</dd>
</dl><hr>
<p>
<h2><a name="Index">Index</a></h2>
<table width="100%">
<tr align="top">
<td valign="top">
<p>
<a href="#Anisotropy">Anisotropy</a><br>
<a href="#Anisotropy:add">Anisotropy:add</a><br>
<a href="#Anisotropy:apply">Anisotropy:apply</a><br>
<a href="#Anisotropy:axis">Anisotropy:axis</a><br>
<a href="#Anisotropy:get">Anisotropy:get</a><br>
<a href="#Anisotropy:member">Anisotropy:member</a><br>
<a href="#Anisotropy:mergeAxes">Anisotropy:mergeAxes</a><br>
<a href="#Anisotropy:numberOfAxes">Anisotropy:numberOfAxes</a><br>
<a href="#Anisotropy:nx">Anisotropy:nx</a><br>
<a href="#Anisotropy:ny">Anisotropy:ny</a><br>
<a href="#Anisotropy:nz">Anisotropy:nz</a><br>
<a href="#Anisotropy:scale">Anisotropy:scale</a><br>
<a href="#Anisotropy:setScale">Anisotropy:setScale</a><br>
<p>
<a href="#AppliedField">AppliedField</a><br>
<a href="#AppliedField:add">AppliedField:add</a><br>
<a href="#AppliedField:get">AppliedField:get</a><br>
<a href="#AppliedField:member">AppliedField:member</a><br>
<a href="#AppliedField:nx">AppliedField:nx</a><br>
<a href="#AppliedField:ny">AppliedField:ny</a><br>
<a href="#AppliedField:nz">AppliedField:nz</a><br>
<a href="#AppliedField:scale">AppliedField:scale</a><br>
<a href="#AppliedField:set">AppliedField:set</a><br>
<a href="#AppliedField:setScale">AppliedField:setScale</a><br>
<a href="#AppliedField:setX">AppliedField:setX</a><br>
<a href="#AppliedField:setY">AppliedField:setY</a><br>
<a href="#AppliedField:setZ">AppliedField:setZ</a><br>
<a href="#AppliedField:x">AppliedField:x</a><br>
<a href="#AppliedField:y">AppliedField:y</a><br>
<a href="#AppliedField:z">AppliedField:z</a><br>
<p>
<a href="#Array.Double">Array.Double</a><br>
<a href="#Array.Double:addAt">Array.Double:addAt</a><br>
<a href="#Array.Double:dot">Array.Double:dot</a><br>
<a href="#Array.Double:get">Array.Double:get</a><br>
<a href="#Array.Double:max">Array.Double:max</a><br>
<a href="#Array.Double:mean">Array.Double:mean</a><br>
<a href="#Array.Double:min">Array.Double:min</a><br>
<a href="#Array.Double:nx">Array.Double:nx</a><br>
<a href="#Array.Double:ny">Array.Double:ny</a><br>
<a href="#Array.Double:nz">Array.Double:nz</a><br>
<a href="#Array.Double:pairwiseMultiply">Array.Double:pairwiseMultiply</a><br>
<a href="#Array.Double:sameSize">Array.Double:sameSize</a><br>
<a href="#Array.Double:scale">Array.Double:scale</a><br>
<a href="#Array.Double:set">Array.Double:set</a><br>
<a href="#Array.Double:setAll">Array.Double:setAll</a><br>
<a href="#Array.Double:sum">Array.Double:sum</a><br>
<a href="#Array.Double:zero">Array.Double:zero</a><br>
<p>
<a href="#Array.DoubleComplex">Array.DoubleComplex</a><br>
<a href="#Array.DoubleComplex:addAt">Array.DoubleComplex:addAt</a><br>
<a href="#Array.DoubleComplex:dot">Array.DoubleComplex:dot</a><br>
<a href="#Array.DoubleComplex:get">Array.DoubleComplex:get</a><br>
<a href="#Array.DoubleComplex:max">Array.DoubleComplex:max</a><br>
<a href="#Array.DoubleComplex:mean">Array.DoubleComplex:mean</a><br>
<a href="#Array.DoubleComplex:min">Array.DoubleComplex:min</a><br>
<a href="#Array.DoubleComplex:nx">Array.DoubleComplex:nx</a><br>
<a href="#Array.DoubleComplex:ny">Array.DoubleComplex:ny</a><br>
<a href="#Array.DoubleComplex:nz">Array.DoubleComplex:nz</a><br>
<a href="#Array.DoubleComplex:pairwiseMultiply">Array.DoubleComplex:pairwiseMultiply</a><br>
<a href="#Array.DoubleComplex:sameSize">Array.DoubleComplex:sameSize</a><br>
<a href="#Array.DoubleComplex:scale">Array.DoubleComplex:scale</a><br>
<a href="#Array.DoubleComplex:set">Array.DoubleComplex:set</a><br>
<a href="#Array.DoubleComplex:setAll">Array.DoubleComplex:setAll</a><br>
<a href="#Array.DoubleComplex:sum">Array.DoubleComplex:sum</a><br>
<a href="#Array.DoubleComplex:zero">Array.DoubleComplex:zero</a><br>
<p>
<a href="#Array.Float">Array.Float</a><br>
<a href="#Array.Float:addAt">Array.Float:addAt</a><br>
<a href="#Array.Float:dot">Array.Float:dot</a><br>
<a href="#Array.Float:get">Array.Float:get</a><br>
<a href="#Array.Float:max">Array.Float:max</a><br>
<a href="#Array.Float:mean">Array.Float:mean</a><br>
<a href="#Array.Float:min">Array.Float:min</a><br>
<a href="#Array.Float:nx">Array.Float:nx</a><br>
<a href="#Array.Float:ny">Array.Float:ny</a><br>
<a href="#Array.Float:nz">Array.Float:nz</a><br>
<a href="#Array.Float:pairwiseMultiply">Array.Float:pairwiseMultiply</a><br>
<a href="#Array.Float:sameSize">Array.Float:sameSize</a><br>
<a href="#Array.Float:scale">Array.Float:scale</a><br>
<a href="#Array.Float:set">Array.Float:set</a><br>
<a href="#Array.Float:setAll">Array.Float:setAll</a><br>
<a href="#Array.Float:sum">Array.Float:sum</a><br>
<a href="#Array.Float:zero">Array.Float:zero</a><br>
<p>
<a href="#Array.FloatComplex">Array.FloatComplex</a><br>
<a href="#Array.FloatComplex:addAt">Array.FloatComplex:addAt</a><br>
<a href="#Array.FloatComplex:dot">Array.FloatComplex:dot</a><br>
<a href="#Array.FloatComplex:get">Array.FloatComplex:get</a><br>
<a href="#Array.FloatComplex:max">Array.FloatComplex:max</a><br>
<a href="#Array.FloatComplex:mean">Array.FloatComplex:mean</a><br>
<a href="#Array.FloatComplex:min">Array.FloatComplex:min</a><br>
<a href="#Array.FloatComplex:nx">Array.FloatComplex:nx</a><br>
<a href="#Array.FloatComplex:ny">Array.FloatComplex:ny</a><br>
<a href="#Array.FloatComplex:nz">Array.FloatComplex:nz</a><br>
<a href="#Array.FloatComplex:pairwiseMultiply">Array.FloatComplex:pairwiseMultiply</a><br>
<a href="#Array.FloatComplex:sameSize">Array.FloatComplex:sameSize</a><br>
<a href="#Array.FloatComplex:scale">Array.FloatComplex:scale</a><br>
<a href="#Array.FloatComplex:set">Array.FloatComplex:set</a><br>
<a href="#Array.FloatComplex:setAll">Array.FloatComplex:setAll</a><br>
<a href="#Array.FloatComplex:sum">Array.FloatComplex:sum</a><br>
<a href="#Array.FloatComplex:zero">Array.FloatComplex:zero</a><br>
<p>
<a href="#Array.Integer">Array.Integer</a><br>
<a href="#Array.Integer:addAt">Array.Integer:addAt</a><br>
<a href="#Array.Integer:dot">Array.Integer:dot</a><br>
<a href="#Array.Integer:get">Array.Integer:get</a><br>
<a href="#Array.Integer:max">Array.Integer:max</a><br>
<a href="#Array.Integer:mean">Array.Integer:mean</a><br>
<a href="#Array.Integer:min">Array.Integer:min</a><br>
<a href="#Array.Integer:nx">Array.Integer:nx</a><br>
<a href="#Array.Integer:ny">Array.Integer:ny</a><br>
<a href="#Array.Integer:nz">Array.Integer:nz</a><br>
<a href="#Array.Integer:pairwiseMultiply">Array.Integer:pairwiseMultiply</a><br>
<a href="#Array.Integer:sameSize">Array.Integer:sameSize</a><br>
<a href="#Array.Integer:scale">Array.Integer:scale</a><br>
<a href="#Array.Integer:set">Array.Integer:set</a><br>
<a href="#Array.Integer:setAll">Array.Integer:setAll</a><br>
<a href="#Array.Integer:sum">Array.Integer:sum</a><br>
<a href="#Array.Integer:zero">Array.Integer:zero</a><br>
<p>
<a href="#Dipole">Dipole</a><br>
<a href="#Dipole:apply">Dipole:apply</a><br>
<a href="#Dipole:getArray">Dipole:getArray</a><br>
<a href="#Dipole:getMatrix">Dipole:getMatrix</a><br>
<a href="#Dipole:member">Dipole:member</a><br>
<a href="#Dipole:nx">Dipole:nx</a><br>
<a href="#Dipole:ny">Dipole:ny</a><br>
<a href="#Dipole:nz">Dipole:nz</a><br>
<a href="#Dipole:scale">Dipole:scale</a><br>
<a href="#Dipole:setArray">Dipole:setArray</a><br>
<a href="#Dipole:setMatrix">Dipole:setMatrix</a><br>
<a href="#Dipole:setScale">Dipole:setScale</a><br>
<a href="#Dipole:setStrength">Dipole:setStrength</a><br>
<a href="#Dipole:setTruncation">Dipole:setTruncation</a><br>
<a href="#Dipole:setUnitCell">Dipole:setUnitCell</a><br>
<a href="#Dipole:strength">Dipole:strength</a><br>
<a href="#Dipole:truncation">Dipole:truncation</a><br>
<a href="#Dipole:unitCell">Dipole:unitCell</a><br>
<p>
<a href="#DipoleEwald3D">DipoleEwald3D</a><br>
<a href="#DipoleEwald3D:NSites">DipoleEwald3D:NSites</a><br>
<a href="#DipoleEwald3D:calculateTensorElement">DipoleEwald3D:calculateTensorElement</a><br>
<a href="#DipoleEwald3D:calculateTensorElementRealR">DipoleEwald3D:calculateTensorElementRealR</a><br>
</td>
<td valign="top">
<a href="#DipoleEwald3D:eta">DipoleEwald3D:eta</a><br>
<a href="#DipoleEwald3D:latticeSize">DipoleEwald3D:latticeSize</a><br>
<a href="#DipoleEwald3D:setLatticeSize">DipoleEwald3D:setLatticeSize</a><br>
<a href="#DipoleEwald3D:setNSites">DipoleEwald3D:setNSites</a><br>
<a href="#DipoleEwald3D:setTau">DipoleEwald3D:setTau</a><br>
<a href="#DipoleEwald3D:setUnitCell">DipoleEwald3D:setUnitCell</a><br>
<a href="#DipoleEwald3D:tau">DipoleEwald3D:tau</a><br>
<a href="#DipoleEwald3D:unitCell">DipoleEwald3D:unitCell</a><br>
<a href="#DipoleEwald3D:volume">DipoleEwald3D:volume</a><br>
<p>
<a href="#DisorderedDipole">DisorderedDipole</a><br>
<a href="#DisorderedDipole:apply">DisorderedDipole:apply</a><br>
<a href="#DisorderedDipole:arrayX">DisorderedDipole:arrayX</a><br>
<a href="#DisorderedDipole:arrayY">DisorderedDipole:arrayY</a><br>
<a href="#DisorderedDipole:arrayZ">DisorderedDipole:arrayZ</a><br>
<a href="#DisorderedDipole:member">DisorderedDipole:member</a><br>
<a href="#DisorderedDipole:nx">DisorderedDipole:nx</a><br>
<a href="#DisorderedDipole:ny">DisorderedDipole:ny</a><br>
<a href="#DisorderedDipole:nz">DisorderedDipole:nz</a><br>
<a href="#DisorderedDipole:scale">DisorderedDipole:scale</a><br>
<a href="#DisorderedDipole:setArrayX">DisorderedDipole:setArrayX</a><br>
<a href="#DisorderedDipole:setArrayY">DisorderedDipole:setArrayY</a><br>
<a href="#DisorderedDipole:setArrayZ">DisorderedDipole:setArrayZ</a><br>
<a href="#DisorderedDipole:setScale">DisorderedDipole:setScale</a><br>
<a href="#DisorderedDipole:setSitePosition">DisorderedDipole:setSitePosition</a><br>
<a href="#DisorderedDipole:setStrength">DisorderedDipole:setStrength</a><br>
<a href="#DisorderedDipole:sitePosition">DisorderedDipole:sitePosition</a><br>
<a href="#DisorderedDipole:strength">DisorderedDipole:strength</a><br>
<p>
<a href="#ElasticBand">ElasticBand</a><br>
<a href="#ElasticBand:compute">ElasticBand:compute</a><br>
<a href="#ElasticBand:energyFunction">ElasticBand:energyFunction</a><br>
<a href="#ElasticBand:getInternalData">ElasticBand:getInternalData</a><br>
<a href="#ElasticBand:initialize">ElasticBand:initialize</a><br>
<a href="#ElasticBand:numberOfPathPoints">ElasticBand:numberOfPathPoints</a><br>
<a href="#ElasticBand:numberOfSites">ElasticBand:numberOfSites</a><br>
<a href="#ElasticBand:setEnergyFunction">ElasticBand:setEnergyFunction</a><br>
<a href="#ElasticBand:setInitialPath">ElasticBand:setInitialPath</a><br>
<a href="#ElasticBand:setInternalData">ElasticBand:setInternalData</a><br>
<a href="#ElasticBand:setNumberOfPathPoints">ElasticBand:setNumberOfPathPoints</a><br>
<a href="#ElasticBand:setSites">ElasticBand:setSites</a><br>
<a href="#ElasticBand:setSpinSystem">ElasticBand:setSpinSystem</a><br>
<a href="#ElasticBand:sites">ElasticBand:sites</a><br>
<a href="#ElasticBand:spin">ElasticBand:spin</a><br>
<a href="#ElasticBand:writePathPointTo">ElasticBand:writePathPointTo</a><br>
<p>
<a href="#Exchange">Exchange</a><br>
<a href="#Exchange:add">Exchange:add</a><br>
<a href="#Exchange:addPath">Exchange:addPath</a><br>
<a href="#Exchange:apply">Exchange:apply</a><br>
<a href="#Exchange:member">Exchange:member</a><br>
<a href="#Exchange:mergePaths">Exchange:mergePaths</a><br>
<a href="#Exchange:numberOfPaths">Exchange:numberOfPaths</a><br>
<a href="#Exchange:nx">Exchange:nx</a><br>
<a href="#Exchange:ny">Exchange:ny</a><br>
<a href="#Exchange:nz">Exchange:nz</a><br>
<a href="#Exchange:path">Exchange:path</a><br>
<a href="#Exchange:pathsFrom">Exchange:pathsFrom</a><br>
<a href="#Exchange:pathsTo">Exchange:pathsTo</a><br>
<a href="#Exchange:periodicXYZ">Exchange:periodicXYZ</a><br>
<a href="#Exchange:scale">Exchange:scale</a><br>
<a href="#Exchange:setPeriodicXYZ">Exchange:setPeriodicXYZ</a><br>
<a href="#Exchange:setScale">Exchange:setScale</a><br>
<p>
<a href="#Interpolate">Interpolate</a><br>
<a href="#Interpolate:__call">Interpolate:__call</a><br>
<a href="#Interpolate:addData">Interpolate:addData</a><br>
<a href="#Interpolate:maxX">Interpolate:maxX</a><br>
<a href="#Interpolate:minX">Interpolate:minX</a><br>
<a href="#Interpolate:value">Interpolate:value</a><br>
<p>
<a href="#Interpolate2D">Interpolate2D</a><br>
<a href="#Interpolate2D:addData">Interpolate2D:addData</a><br>
<a href="#Interpolate2D:compile">Interpolate2D:compile</a><br>
<a href="#Interpolate2D:setInvalidValue">Interpolate2D:setInvalidValue</a><br>
<a href="#Interpolate2D:validRange">Interpolate2D:validRange</a><br>
<a href="#Interpolate2D:value">Interpolate2D:value</a><br>
<p>
<a href="#LLG.Align">LLG.Align</a><br>
<a href="#LLG.Align:apply">LLG.Align:apply</a><br>
<a href="#LLG.Align:disableRenormalization">LLG.Align:disableRenormalization</a><br>
<a href="#LLG.Align:setDisableRenormalization">LLG.Align:setDisableRenormalization</a><br>
<a href="#LLG.Align:setThermalOnlyFirstTerm">LLG.Align:setThermalOnlyFirstTerm</a><br>
<a href="#LLG.Align:thermalOnlyFirstTerm">LLG.Align:thermalOnlyFirstTerm</a><br>
<p>
<a href="#LLG.Base">LLG.Base</a><br>
<a href="#LLG.Base:apply">LLG.Base:apply</a><br>
<a href="#LLG.Base:disableRenormalization">LLG.Base:disableRenormalization</a><br>
<a href="#LLG.Base:setDisableRenormalization">LLG.Base:setDisableRenormalization</a><br>
<a href="#LLG.Base:setThermalOnlyFirstTerm">LLG.Base:setThermalOnlyFirstTerm</a><br>
<a href="#LLG.Base:thermalOnlyFirstTerm">LLG.Base:thermalOnlyFirstTerm</a><br>
<p>
<a href="#LLG.Cartesian">LLG.Cartesian</a><br>
<a href="#LLG.Cartesian:apply">LLG.Cartesian:apply</a><br>
<a href="#LLG.Cartesian:disableRenormalization">LLG.Cartesian:disableRenormalization</a><br>
<a href="#LLG.Cartesian:setDisableRenormalization">LLG.Cartesian:setDisableRenormalization</a><br>
<a href="#LLG.Cartesian:setThermalOnlyFirstTerm">LLG.Cartesian:setThermalOnlyFirstTerm</a><br>
<a href="#LLG.Cartesian:thermalOnlyFirstTerm">LLG.Cartesian:thermalOnlyFirstTerm</a><br>
<p>
<a href="#LLG.Fake">LLG.Fake</a><br>
<a href="#LLG.Fake:apply">LLG.Fake:apply</a><br>
<a href="#LLG.Fake:disableRenormalization">LLG.Fake:disableRenormalization</a><br>
<a href="#LLG.Fake:setDisableRenormalization">LLG.Fake:setDisableRenormalization</a><br>
<a href="#LLG.Fake:setThermalOnlyFirstTerm">LLG.Fake:setThermalOnlyFirstTerm</a><br>
<a href="#LLG.Fake:thermalOnlyFirstTerm">LLG.Fake:thermalOnlyFirstTerm</a><br>
<p>
<a href="#LLG.Quaternion">LLG.Quaternion</a><br>
<a href="#LLG.Quaternion:apply">LLG.Quaternion:apply</a><br>
<a href="#LLG.Quaternion:disableRenormalization">LLG.Quaternion:disableRenormalization</a><br>
<a href="#LLG.Quaternion:setDisableRenormalization">LLG.Quaternion:setDisableRenormalization</a><br>
<a href="#LLG.Quaternion:setThermalOnlyFirstTerm">LLG.Quaternion:setThermalOnlyFirstTerm</a><br>
<a href="#LLG.Quaternion:thermalOnlyFirstTerm">LLG.Quaternion:thermalOnlyFirstTerm</a><br>
<p>
<a href="#LongRange">LongRange</a><br>
<a href="#LongRange:apply">LongRange:apply</a><br>
<a href="#LongRange:getArray">LongRange:getArray</a><br>
<a href="#LongRange:getMatrix">LongRange:getMatrix</a><br>
<a href="#LongRange:member">LongRange:member</a><br>
<a href="#LongRange:nx">LongRange:nx</a><br>
<a href="#LongRange:ny">LongRange:ny</a><br>
<a href="#LongRange:nz">LongRange:nz</a><br>
<a href="#LongRange:scale">LongRange:scale</a><br>
<a href="#LongRange:setArray">LongRange:setArray</a><br>
<a href="#LongRange:setMatrix">LongRange:setMatrix</a><br>
<a href="#LongRange:setScale">LongRange:setScale</a><br>
<a href="#LongRange:setStrength">LongRange:setStrength</a><br>
<a href="#LongRange:setTruncation">LongRange:setTruncation</a><br>
<a href="#LongRange:setUnitCell">LongRange:setUnitCell</a><br>
<a href="#LongRange:strength">LongRange:strength</a><br>
<a href="#LongRange:truncation">LongRange:truncation</a><br>
<a href="#LongRange:unitCell">LongRange:unitCell</a><br>
<p>
<a href="#LongRange2D">LongRange2D</a><br>
<a href="#LongRange2D:apply">LongRange2D:apply</a><br>
<a href="#LongRange2D:internalData">LongRange2D:internalData</a><br>
<a href="#LongRange2D:makeData">LongRange2D:makeData</a><br>
<a href="#LongRange2D:makeDataFunction">LongRange2D:makeDataFunction</a><br>
<a href="#LongRange2D:member">LongRange2D:member</a><br>
<a href="#LongRange2D:nx">LongRange2D:nx</a><br>
<a href="#LongRange2D:ny">LongRange2D:ny</a><br>
<a href="#LongRange2D:nz">LongRange2D:nz</a><br>
<a href="#LongRange2D:scale">LongRange2D:scale</a><br>
<a href="#LongRange2D:setCompileRequired">LongRange2D:setCompileRequired</a><br>
<a href="#LongRange2D:setInternalData">LongRange2D:setInternalData</a><br>
<a href="#LongRange2D:setMakeDataFunction">LongRange2D:setMakeDataFunction</a><br>
<a href="#LongRange2D:setNewDataRequired">LongRange2D:setNewDataRequired</a><br>
<a href="#LongRange2D:setScale">LongRange2D:setScale</a><br>
<a href="#LongRange2D:setStrength">LongRange2D:setStrength</a><br>
</td>
<td valign="top">
<a href="#LongRange2D:setTensorArray">LongRange2D:setTensorArray</a><br>
<a href="#LongRange2D:strength">LongRange2D:strength</a><br>
<a href="#LongRange2D:tensorArray">LongRange2D:tensorArray</a><br>
<p>
<a href="#LongRange3D">LongRange3D</a><br>
<a href="#LongRange3D:apply">LongRange3D:apply</a><br>
<a href="#LongRange3D:internalData">LongRange3D:internalData</a><br>
<a href="#LongRange3D:loadTensors">LongRange3D:loadTensors</a><br>
<a href="#LongRange3D:makeData">LongRange3D:makeData</a><br>
<a href="#LongRange3D:makeDataFunction">LongRange3D:makeDataFunction</a><br>
<a href="#LongRange3D:member">LongRange3D:member</a><br>
<a href="#LongRange3D:nx">LongRange3D:nx</a><br>
<a href="#LongRange3D:ny">LongRange3D:ny</a><br>
<a href="#LongRange3D:nz">LongRange3D:nz</a><br>
<a href="#LongRange3D:saveTensors">LongRange3D:saveTensors</a><br>
<a href="#LongRange3D:scale">LongRange3D:scale</a><br>
<a href="#LongRange3D:setCompileRequired">LongRange3D:setCompileRequired</a><br>
<a href="#LongRange3D:setInternalData">LongRange3D:setInternalData</a><br>
<a href="#LongRange3D:setMakeDataFunction">LongRange3D:setMakeDataFunction</a><br>
<a href="#LongRange3D:setMatrix">LongRange3D:setMatrix</a><br>
<a href="#LongRange3D:setNewDataRequired">LongRange3D:setNewDataRequired</a><br>
<a href="#LongRange3D:setScale">LongRange3D:setScale</a><br>
<a href="#LongRange3D:setStrength">LongRange3D:setStrength</a><br>
<a href="#LongRange3D:setTensorArray">LongRange3D:setTensorArray</a><br>
<a href="#LongRange3D:strength">LongRange3D:strength</a><br>
<a href="#LongRange3D:tensorArray">LongRange3D:tensorArray</a><br>
<p>
<a href="#Magnetostatic">Magnetostatic</a><br>
<a href="#Magnetostatic:apply">Magnetostatic:apply</a><br>
<a href="#Magnetostatic:cellDimensions">Magnetostatic:cellDimensions</a><br>
<a href="#Magnetostatic:crossoverTolerance">Magnetostatic:crossoverTolerance</a><br>
<a href="#Magnetostatic:getArray">Magnetostatic:getArray</a><br>
<a href="#Magnetostatic:getMatrix">Magnetostatic:getMatrix</a><br>
<a href="#Magnetostatic:member">Magnetostatic:member</a><br>
<a href="#Magnetostatic:nx">Magnetostatic:nx</a><br>
<a href="#Magnetostatic:ny">Magnetostatic:ny</a><br>
<a href="#Magnetostatic:nz">Magnetostatic:nz</a><br>
<a href="#Magnetostatic:scale">Magnetostatic:scale</a><br>
<a href="#Magnetostatic:setArray">Magnetostatic:setArray</a><br>
<a href="#Magnetostatic:setCellDimensions">Magnetostatic:setCellDimensions</a><br>
<a href="#Magnetostatic:setCrossoverTolerance">Magnetostatic:setCrossoverTolerance</a><br>
<a href="#Magnetostatic:setMatrix">Magnetostatic:setMatrix</a><br>
<a href="#Magnetostatic:setScale">Magnetostatic:setScale</a><br>
<a href="#Magnetostatic:setStrength">Magnetostatic:setStrength</a><br>
<a href="#Magnetostatic:setTruncation">Magnetostatic:setTruncation</a><br>
<a href="#Magnetostatic:setUnitCell">Magnetostatic:setUnitCell</a><br>
<a href="#Magnetostatic:strength">Magnetostatic:strength</a><br>
<a href="#Magnetostatic:truncation">Magnetostatic:truncation</a><br>
<a href="#Magnetostatic:unitCell">Magnetostatic:unitCell</a><br>
<p>
<a href="#Magnetostatics2D">Magnetostatics2D</a><br>
<a href="#Magnetostatics2D:apply">Magnetostatics2D:apply</a><br>
<a href="#Magnetostatics2D:getMatrix">Magnetostatics2D:getMatrix</a><br>
<a href="#Magnetostatics2D:grainSize">Magnetostatics2D:grainSize</a><br>
<a href="#Magnetostatics2D:internalData">Magnetostatics2D:internalData</a><br>
<a href="#Magnetostatics2D:makeData">Magnetostatics2D:makeData</a><br>
<a href="#Magnetostatics2D:makeDataFunction">Magnetostatics2D:makeDataFunction</a><br>
<a href="#Magnetostatics2D:member">Magnetostatics2D:member</a><br>
<a href="#Magnetostatics2D:nx">Magnetostatics2D:nx</a><br>
<a href="#Magnetostatics2D:ny">Magnetostatics2D:ny</a><br>
<a href="#Magnetostatics2D:nz">Magnetostatics2D:nz</a><br>
<a href="#Magnetostatics2D:scale">Magnetostatics2D:scale</a><br>
<a href="#Magnetostatics2D:setCompileRequired">Magnetostatics2D:setCompileRequired</a><br>
<a href="#Magnetostatics2D:setGrainSize">Magnetostatics2D:setGrainSize</a><br>
<a href="#Magnetostatics2D:setInternalData">Magnetostatics2D:setInternalData</a><br>
<a href="#Magnetostatics2D:setMakeDataFunction">Magnetostatics2D:setMakeDataFunction</a><br>
<a href="#Magnetostatics2D:setNewDataRequired">Magnetostatics2D:setNewDataRequired</a><br>
<a href="#Magnetostatics2D:setScale">Magnetostatics2D:setScale</a><br>
<a href="#Magnetostatics2D:setStrength">Magnetostatics2D:setStrength</a><br>
<a href="#Magnetostatics2D:setTensorArray">Magnetostatics2D:setTensorArray</a><br>
<a href="#Magnetostatics2D:setTruncation">Magnetostatics2D:setTruncation</a><br>
<a href="#Magnetostatics2D:setUnitCell">Magnetostatics2D:setUnitCell</a><br>
<a href="#Magnetostatics2D:strength">Magnetostatics2D:strength</a><br>
<a href="#Magnetostatics2D:tensorArray">Magnetostatics2D:tensorArray</a><br>
<a href="#Magnetostatics2D:truncation">Magnetostatics2D:truncation</a><br>
<a href="#Magnetostatics2D:unitCell">Magnetostatics2D:unitCell</a><br>
<p>
<a href="#Magnetostatics3D">Magnetostatics3D</a><br>
<a href="#Magnetostatics3D:apply">Magnetostatics3D:apply</a><br>
<a href="#Magnetostatics3D:getMatrix">Magnetostatics3D:getMatrix</a><br>
<a href="#Magnetostatics3D:grainSize">Magnetostatics3D:grainSize</a><br>
<a href="#Magnetostatics3D:internalData">Magnetostatics3D:internalData</a><br>
<a href="#Magnetostatics3D:makeData">Magnetostatics3D:makeData</a><br>
<a href="#Magnetostatics3D:makeDataFunction">Magnetostatics3D:makeDataFunction</a><br>
<a href="#Magnetostatics3D:member">Magnetostatics3D:member</a><br>
<a href="#Magnetostatics3D:nx">Magnetostatics3D:nx</a><br>
<a href="#Magnetostatics3D:ny">Magnetostatics3D:ny</a><br>
<a href="#Magnetostatics3D:nz">Magnetostatics3D:nz</a><br>
<a href="#Magnetostatics3D:scale">Magnetostatics3D:scale</a><br>
<a href="#Magnetostatics3D:setCompileRequired">Magnetostatics3D:setCompileRequired</a><br>
<a href="#Magnetostatics3D:setGrainSize">Magnetostatics3D:setGrainSize</a><br>
<a href="#Magnetostatics3D:setInternalData">Magnetostatics3D:setInternalData</a><br>
<a href="#Magnetostatics3D:setMakeDataFunction">Magnetostatics3D:setMakeDataFunction</a><br>
<a href="#Magnetostatics3D:setNewDataRequired">Magnetostatics3D:setNewDataRequired</a><br>
<a href="#Magnetostatics3D:setScale">Magnetostatics3D:setScale</a><br>
<a href="#Magnetostatics3D:setStrength">Magnetostatics3D:setStrength</a><br>
<a href="#Magnetostatics3D:setTensorArray">Magnetostatics3D:setTensorArray</a><br>
<a href="#Magnetostatics3D:setTruncation">Magnetostatics3D:setTruncation</a><br>
<a href="#Magnetostatics3D:setUnitCell">Magnetostatics3D:setUnitCell</a><br>
<a href="#Magnetostatics3D:strength">Magnetostatics3D:strength</a><br>
<a href="#Magnetostatics3D:tensorArray">Magnetostatics3D:tensorArray</a><br>
<a href="#Magnetostatics3D:truncation">Magnetostatics3D:truncation</a><br>
<a href="#Magnetostatics3D:unitCell">Magnetostatics3D:unitCell</a><br>
<p>
<a href="#Random.Base">Random.Base</a><br>
<a href="#Random.Base:normal">Random.Base:normal</a><br>
<a href="#Random.Base:rand">Random.Base:rand</a><br>
<a href="#Random.Base:setSeed">Random.Base:setSeed</a><br>
<a href="#Random.Base:uniform">Random.Base:uniform</a><br>
<p>
<a href="#Random.CRand">Random.CRand</a><br>
<a href="#Random.CRand:normal">Random.CRand:normal</a><br>
<a href="#Random.CRand:rand">Random.CRand:rand</a><br>
<a href="#Random.CRand:setSeed">Random.CRand:setSeed</a><br>
<a href="#Random.CRand:uniform">Random.CRand:uniform</a><br>
<p>
<a href="#Random.Isaac">Random.Isaac</a><br>
<a href="#Random.Isaac:normal">Random.Isaac:normal</a><br>
<a href="#Random.Isaac:rand">Random.Isaac:rand</a><br>
<a href="#Random.Isaac:setSeed">Random.Isaac:setSeed</a><br>
<a href="#Random.Isaac:uniform">Random.Isaac:uniform</a><br>
<p>
<a href="#Random.MersenneTwister">Random.MersenneTwister</a><br>
<a href="#Random.MersenneTwister:normal">Random.MersenneTwister:normal</a><br>
<a href="#Random.MersenneTwister:rand">Random.MersenneTwister:rand</a><br>
<a href="#Random.MersenneTwister:setSeed">Random.MersenneTwister:setSeed</a><br>
<a href="#Random.MersenneTwister:uniform">Random.MersenneTwister:uniform</a><br>
<p>
<a href="#SQLite3">SQLite3</a><br>
<a href="#SQLite3:bootstrap">SQLite3:bootstrap</a><br>
<a href="#SQLite3:changes">SQLite3:changes</a><br>
<a href="#SQLite3:close">SQLite3:close</a><br>
<a href="#SQLite3:escapeString">SQLite3:escapeString</a><br>
<a href="#SQLite3:exec">SQLite3:exec</a><br>
<a href="#SQLite3:setupBootstrap">SQLite3:setupBootstrap</a><br>
<p>
<a href="#SpinSystem">SpinSystem</a><br>
<a href="#SpinSystem:addFields">SpinSystem:addFields</a><br>
<a href="#SpinSystem:alpha">SpinSystem:alpha</a><br>
<a href="#SpinSystem:copy">SpinSystem:copy</a><br>
<a href="#SpinSystem:copyFieldTo">SpinSystem:copyFieldTo</a><br>
<a href="#SpinSystem:copyFieldsTo">SpinSystem:copyFieldsTo</a><br>
<a href="#SpinSystem:copySpinsTo">SpinSystem:copySpinsTo</a><br>
<a href="#SpinSystem:copyTo">SpinSystem:copyTo</a><br>
<a href="#SpinSystem:diff">SpinSystem:diff</a><br>
<a href="#SpinSystem:extraData">SpinSystem:extraData</a><br>
</td>
<td valign="top">
<a href="#SpinSystem:extraDataIterator">SpinSystem:extraDataIterator</a><br>
<a href="#SpinSystem:field">SpinSystem:field</a><br>
<a href="#SpinSystem:fieldArrayX">SpinSystem:fieldArrayX</a><br>
<a href="#SpinSystem:fieldArrayY">SpinSystem:fieldArrayY</a><br>
<a href="#SpinSystem:fieldArrayZ">SpinSystem:fieldArrayZ</a><br>
<a href="#SpinSystem:gamma">SpinSystem:gamma</a><br>
<a href="#SpinSystem:invalidateFourierData">SpinSystem:invalidateFourierData</a><br>
<a href="#SpinSystem:inverseSpin">SpinSystem:inverseSpin</a><br>
<a href="#SpinSystem:inverseSpinX">SpinSystem:inverseSpinX</a><br>
<a href="#SpinSystem:inverseSpinY">SpinSystem:inverseSpinY</a><br>
<a href="#SpinSystem:inverseSpinZ">SpinSystem:inverseSpinZ</a><br>
<a href="#SpinSystem:moveToward">SpinSystem:moveToward</a><br>
<a href="#SpinSystem:netField">SpinSystem:netField</a><br>
<a href="#SpinSystem:netMoment">SpinSystem:netMoment</a><br>
<a href="#SpinSystem:nx">SpinSystem:nx</a><br>
<a href="#SpinSystem:ny">SpinSystem:ny</a><br>
<a href="#SpinSystem:nz">SpinSystem:nz</a><br>
<a href="#SpinSystem:resetFields">SpinSystem:resetFields</a><br>
<a href="#SpinSystem:rotateToward">SpinSystem:rotateToward</a><br>
<a href="#SpinSystem:setAlpha">SpinSystem:setAlpha</a><br>
<a href="#SpinSystem:setExtraData">SpinSystem:setExtraData</a><br>
<a href="#SpinSystem:setFieldArrayX">SpinSystem:setFieldArrayX</a><br>
<a href="#SpinSystem:setFieldArrayY">SpinSystem:setFieldArrayY</a><br>
<a href="#SpinSystem:setFieldArrayZ">SpinSystem:setFieldArrayZ</a><br>
<a href="#SpinSystem:setGamma">SpinSystem:setGamma</a><br>
<a href="#SpinSystem:setSiteAlpha">SpinSystem:setSiteAlpha</a><br>
<a href="#SpinSystem:setSiteAlphaArray">SpinSystem:setSiteAlphaArray</a><br>
<a href="#SpinSystem:setSiteGamma">SpinSystem:setSiteGamma</a><br>
<a href="#SpinSystem:setSiteGammaArray">SpinSystem:setSiteGammaArray</a><br>
<a href="#SpinSystem:setSlotUsed">SpinSystem:setSlotUsed</a><br>
<a href="#SpinSystem:setSpin">SpinSystem:setSpin</a><br>
<a href="#SpinSystem:setSpinArrayM">SpinSystem:setSpinArrayM</a><br>
<a href="#SpinSystem:setSpinArrayX">SpinSystem:setSpinArrayX</a><br>
<a href="#SpinSystem:setSpinArrayY">SpinSystem:setSpinArrayY</a><br>
<a href="#SpinSystem:setSpinArrayZ">SpinSystem:setSpinArrayZ</a><br>
<a href="#SpinSystem:setSpinTPR">SpinSystem:setSpinTPR</a><br>
<a href="#SpinSystem:setTime">SpinSystem:setTime</a><br>
<a href="#SpinSystem:setTimeStep">SpinSystem:setTimeStep</a><br>
<a href="#SpinSystem:siteAlpha">SpinSystem:siteAlpha</a><br>
<a href="#SpinSystem:siteAlphaArray">SpinSystem:siteAlphaArray</a><br>
<a href="#SpinSystem:siteGamma">SpinSystem:siteGamma</a><br>
<a href="#SpinSystem:siteGammaArray">SpinSystem:siteGammaArray</a><br>
<a href="#SpinSystem:siteIterator">SpinSystem:siteIterator</a><br>
<a href="#SpinSystem:slotUsed">SpinSystem:slotUsed</a><br>
<a href="#SpinSystem:spin">SpinSystem:spin</a><br>
<a href="#SpinSystem:spinArrayM">SpinSystem:spinArrayM</a><br>
<a href="#SpinSystem:spinArrayX">SpinSystem:spinArrayX</a><br>
<a href="#SpinSystem:spinArrayY">SpinSystem:spinArrayY</a><br>
<a href="#SpinSystem:spinArrayZ">SpinSystem:spinArrayZ</a><br>
<a href="#SpinSystem:spinTPR">SpinSystem:spinTPR</a><br>
<a href="#SpinSystem:sumFields">SpinSystem:sumFields</a><br>
<a href="#SpinSystem:time">SpinSystem:time</a><br>
<a href="#SpinSystem:timeStep">SpinSystem:timeStep</a><br>
<a href="#SpinSystem:unitSpin">SpinSystem:unitSpin</a><br>
<p>
<a href="#Thermal">Thermal</a><br>
<a href="#Thermal:apply">Thermal:apply</a><br>
<a href="#Thermal:arrayScale">Thermal:arrayScale</a><br>
<a href="#Thermal:get">Thermal:get</a><br>
<a href="#Thermal:member">Thermal:member</a><br>
<a href="#Thermal:nx">Thermal:nx</a><br>
<a href="#Thermal:ny">Thermal:ny</a><br>
<a href="#Thermal:nz">Thermal:nz</a><br>
<a href="#Thermal:random">Thermal:random</a><br>
<a href="#Thermal:scale">Thermal:scale</a><br>
<a href="#Thermal:scaleSite">Thermal:scaleSite</a><br>
<a href="#Thermal:set">Thermal:set</a><br>
<a href="#Thermal:setArrayScale">Thermal:setArrayScale</a><br>
<a href="#Thermal:setScale">Thermal:setScale</a><br>
<a href="#Thermal:setTemperature">Thermal:setTemperature</a><br>
<a href="#Thermal:temperature">Thermal:temperature</a><br>
<p>
<a href="#Timer">Timer</a><br>
<a href="#Timer:elapsed">Timer:elapsed</a><br>
<a href="#Timer:nanoseconds">Timer:nanoseconds</a><br>
<a href="#Timer:pause">Timer:pause</a><br>
<a href="#Timer:seconds">Timer:seconds</a><br>
<a href="#Timer:start">Timer:start</a><br>
<a href="#Timer:stop">Timer:stop</a><br>
<p>
<a href="#Wood">Wood</a><br>
<a href="#Wood.effectiveAnisotropy">Wood.effectiveAnisotropy</a><br>
<a href="#Wood:adjustMagnetostatics">Wood:adjustMagnetostatics</a><br>
<a href="#Wood:apply">Wood:apply</a><br>
<a href="#Wood:calculateEnergyBarriers">Wood:calculateEnergyBarriers</a><br>
<a href="#Wood:energyBarrier">Wood:energyBarrier</a><br>
<a href="#Wood:getDemag">Wood:getDemag</a><br>
<a href="#Wood:member">Wood:member</a><br>
<a href="#Wood:nx">Wood:nx</a><br>
<a href="#Wood:ny">Wood:ny</a><br>
<a href="#Wood:nz">Wood:nz</a><br>
<a href="#Wood:scale">Wood:scale</a><br>
<a href="#Wood:setScale">Wood:setScale</a><br>
<p>
<a href="#_G">_G</a><br>
<a href="#checkpointFromString">checkpointFromString</a><br>
<a href="#checkpointLoad">checkpointLoad</a><br>
<a href="#checkpointSave">checkpointSave</a><br>
<a href="#checkpointToString">checkpointToString</a><br>
<p>
<a href="#math">math</a><br>
<a href="#math.angleBetween">math.angleBetween</a><br>
<a href="#math.cross">math.cross</a><br>
<a href="#math.dot">math.dot</a><br>
<a href="#math.norm">math.norm</a><br>
<a href="#math.project">math.project</a><br>
<a href="#math.rotateAboutBy">math.rotateAboutBy</a><br>
<a href="#math.scaledVector">math.scaledVector</a><br>
<p>
<a href="#mpi">mpi</a><br>
<a href="#mpi.barrier">mpi.barrier</a><br>
<a href="#mpi.bcast">mpi.bcast</a><br>
<a href="#mpi.cart_coord">mpi.cart_coord</a><br>
<a href="#mpi.cart_create">mpi.cart_create</a><br>
<a href="#mpi.cart_rank">mpi.cart_rank</a><br>
<a href="#mpi.comm_split">mpi.comm_split</a><br>
<a href="#mpi.gather">mpi.gather</a><br>
<a href="#mpi.get_processor_name">mpi.get_processor_name</a><br>
<a href="#mpi.get_rank">mpi.get_rank</a><br>
<a href="#mpi.get_size">mpi.get_size</a><br>
<a href="#mpi.irecv">mpi.irecv</a><br>
<a href="#mpi.isend">mpi.isend</a><br>
<a href="#mpi.range">mpi.range</a><br>
<a href="#mpi.recv">mpi.recv</a><br>
<a href="#mpi.send">mpi.send</a><br>
<p>
<a href="#mpi.request">mpi.request</a><br>
<a href="#mpi.request:cancel">mpi.request:cancel</a><br>
<a href="#mpi.request:data">mpi.request:data</a><br>
<a href="#mpi.request:test">mpi.request:test</a><br>
<a href="#mpi.request:wait">mpi.request:wait</a><br>
<p>
<a href="#dofile(maglua://RungeKutta.lua)">dofile("maglua://RungeKutta.lua")</a><br>
<p>
<a href="#dofile(maglua://POVRay.lua)">dofile("maglua://POVRay.lua")</a><br>
<p>
<a href="#dofile(maglua://ColorMap.lua)">dofile("maglua://ColorMap.lua")</a><br>
<p>
<a href="#dofile(maglua://Help.lua)">dofile("maglua://Help.lua")</a><br>
<p>
<a href="#dofile(maglua://PredictorCorrector.lua)">dofile("maglua://PredictorCorrector.lua")</a><br>
<p>
<a href="#dofile(maglua://AdaptiveTimeStep.lua)">dofile("maglua://AdaptiveTimeStep.lua")</a><br>
<p>
<a href="#dofile(maglua://MakeMacro.lua)">dofile("maglua://MakeMacro.lua")</a><br>
<p>
<a href="#dofile(maglua://CGS.lua)">dofile("maglua://CGS.lua")</a><br>
</td></tr></table><hr>
<table>
<tr><td width=15%>MagLua Revision:<td>     307
<tr><td width=15%>Last Changed Author:<td> jmercer
<tr><td width=15%>Compiler:<td>            icc (ICC) 12.1.0 20110811
</table>
<hr></body>
</html>
